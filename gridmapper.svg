<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <desc>Gridmapper, a simple tool to create dungeon maps</desc>

  <script type="application/javascript"><![CDATA[
/* The Map is where we store everything about the map. The fooElement
 * members point to the SVG elements where we'll be adding stuff and
 * the foo member are arrays with references to those elements,
 * indexed by x and y. We need multiple elements because that's how we
 * make sure that they are painted in the correct order -- a sort of
 * primitive z-axis. The ui Element is a transparent overlay where
 * we'll register the mouse event handlers.
 *
 * If you want to change the size of the map, simply change width and
 * height. The tileWidth is the size of one square, in pixels. You can
 * change that as well. Everything shold be scaled accordingly
 * (including the help screen).
 */

var Map = {
    width: 30, // how many columns
    height: 21, // how many rows
    tileWidth: 20, // tile size in pixels
    ui: null, // the SVG element with the event handlers
    floorElement: null, // the SVG element for the floor
    floor: [], // the model for the floor
    stairsElement: null, // the SVG element for the stairs
    stairs: [], // the model for the stairs
    wallsElement: null, // the SVG element for the walls
    walls: [], // the model for the walls
};

/* The Pen holds information about the mouse. */

var Pen = {
    x: null,
    y: null,
    type: null,
    position: function(evt) {
        return {
            x: Math.floor(Pen.evt.clientX / Map.tileWidth) - 1, // empty column to the left
            y: Math.floor(Pen.evt.clientY / Map.tileWidth) - 1
        }; // empty row at the top
    },
    update: function(evt) {
        var pos = this.position(evt);
        this.x = pos.x;
        this.y = pos.y;
    },
    // return true if we moved
    move_to: function(target) {
        if (this.x != target.x) {
            this.x += target.x > this.x ? 1 : -1;
            return true;
        } else if (this.y != target.y) {
            this.y += target.y > this.y ? 1 : -1;
            return true;
        }
        return false;
    },
};

/* These two constants are used when creating new SVG elements and the
 * href attribute linking them to each other.
 */

var svg_ns   = "http://www.w3.org/2000/svg";
var xlink_ns = "http://www.w3.org/1999/xlink";

/* We maintain an undo and a redo list. Whenever you do something that
 * the user can undo, you need to call Commands.push with two
 * functions, the how-to-undo-it step and the how-to-do-it step.
 * how-to-do-it will be called once on order to do it. When the user
 * undoes something, our index is decremented and we execute the
 * appropriate undo step. When the user redoes something, our index is
 * incremented and we execute the appropriate redo step. If the user
 * has undone some steps and then pushes new commands, we discard the
 * steps we have undone. */

var Commands = {
    i: -1, // where are we in the undo/redo chain
    undoSteps: [],
    redoSteps: [],
    push: function(undoStep, redoStep) {
        // once we're pushing new steps, discard the undone steps
        while (this.undoSteps.length - 1 > this.i) {
            this.undoSteps.pop();
            this.redoSteps.pop();
        }
        this.undoSteps.push(undoStep);
        this.redoSteps.push(redoStep);
        this.i++;
        // finally, execute the last step
        redoStep();
    },
    undo: function() {
        if (this.i >= 0) {
            this.undoSteps[this.i--]();
        }
    },
    redo: function() {
        if (this.i < this.redoSteps.length - 1) {
            this.redoSteps[++this.i]();
        }
    },
};

/* The animations at the beginning are taken from these examples:
 * http://javascript.info/tutorial/animation */

function animate(opts) {
    var start = new Date();
    var id = setInterval(function() {
        var timePassed = new Date() - start;
        var progress = timePassed / opts.duration;
        if (progress > 1) progress = 1;
        var delta = opts.delta(progress);
        opts.step(delta);
        if (progress == 1) {
            clearInterval(id);
        }
    }, opts.delay || 10);
}

function linear(progress) {
    return progress;
}

function bounce(progress) {
    for(var a = 0, b = 1; 1; a += b, b /= 2) {
        if (progress >= (7 - 4 * a) / 11) {
            return -Math.pow((11 - 6 * a - 11 * progress) / 4, 2) + Math.pow(b, 2)
        }
    }
}

function makeEaseOut(delta) {  
    return function(progress) {
        return 1 - delta(1 - progress);
    }
}

var bounceEaseOut = makeEaseOut(bounce);

function resize(element, to_width, to_height, delta, duration) {
    var from_width  = element.getBBox().width;  // assuming px
    var from_height = element.getBBox().height; // assuming px
    animate({
        delay: 10,
        duration: duration || 1000, // 1 sec by default
        delta: delta,
        step: function(delta) {
            element.setAttribute("width",  from_width  + (to_width  - from_width)  * delta);
            element.setAttribute("height", from_height + (to_height - from_height) * delta);
        }
    })
}

function move(element, dx, dy, delta, duration) {
    var old = element.getAttribute("transform")||"";
    if (old != "") {
        old += ",";
    }
    animate({
        delay: 10,
        duration: duration || 1000, // 1 sec by default
        delta: delta,
        step: function(delta) {
            element.setAttribute("transform", old + "translate(" + dx * delta + "," + dy * delta + ")");
        }
    })
}

/* We store the entire document in a data URI and offer it for downlod
 * using the HTML5 download attribute. Chrome 40 will still load that
 * file instead of downloading it. Perhaps a namespace issue? After
 * all, there is no such download attribute for SVG or XHTML. */

function download() {
    var source = btoa("<?xml version=\"1.0\" standalone=\"no\"?>\n"
                      + "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
                      + "<svg version=\"1.1\"\n"
                      + "     xmlns=\"http://www.w3.org/2000/svg\"\n"
                      + "     xmlns:xlink=\"http://www.w3.org/1999/xlink\">"
                      + document.documentElement.innerHTML
                      + "</svg>");
    var link = document.getElementById("download");
    var text = link.firstElementChild.firstChild.nodeValue;
    link.firstElementChild.firstChild.nodeValue = "Download";
    var href = link.getAttributeNS(xlink_ns, "href");
    link.setAttributeNS(null, "download", "gridmapper.svg");
    link.setAttributeNS(xlink_ns, "href", "data:image/svg+xml;base64," + source);
    // reset after 10s
    var t = setInterval(function() {
        link.setAttributeNS(xlink_ns, "href", href);
        link.firstElementChild.firstChild.nodeValue = text;
        clearInterval(t);
    }, 10000);
}

/* You can add more tiles at whatever scale you want and this code
 * will determine the scale by comparing your tile's width with the
 * tile width in use by the map. The original tiles are all based on a
 * 10x10 grid and are scaled up to 20x20, for example. The easiest way
 * to do this is to use a <g> element and give it an appropriate width
 * attribute. */

function scale_tiles() {
    var tiles = document.getElementsByTagName("defs")[0].childNodes;
    for (var i = 0; i < tiles.length; ++i) {
        if (tiles[i].nodeType===Node.ELEMENT_NODE
            && tiles[i].hasAttribute("width")) {
            var scale = Map.tileWidth / tiles[i].getAttribute("width");
            if (scale != 1) {
                tiles[i].setAttribute("transform", "scale("+scale+","+scale+")");
            }
        }
    }
}

function create_tile(x, y, type) {
    var tile = document.createElementNS(svg_ns, "use");
    tile.setAttributeNS(null, "id", type + "_" + x + "_" + y);
    tile.setAttributeNS(null, "x", (x + 1) * Map.tileWidth); // empty column to the left
    tile.setAttributeNS(null, "y", (y + 1) * Map.tileWidth); // empty row at the top
    tile.type = type;
    tile.setAttributeNS(xlink_ns, "href", "#" + type);
    return tile;
}

function wall_rotation(x, y, rotate) {
    // find an unused rotation
    var candidate = [rotate,
                     (rotate + 90) % 360,
                     (rotate + 180) % 360,
                     (rotate + 270) % 360];
    var existingWalls = [];
    for (var i = 0; i < Map.walls[x][y].length; i++) {
        existingWalls.push(Map.walls[x][y][i].getAttribute("rotate"));
    }
    search: for (var c = 0; c < 4; c++) {
        for (var i = 0; i < existingWalls.length; i++) {
            if (candidate[c]==existingWalls[i]) {
                continue search;
            }
        }
        return candidate[c];
    }
}

function rotate_tile(tile, type, x, y, angle) {
    tile.setAttribute("rotate", angle);
    if (angle===180 && type==="concealed") {
        tile.setAttributeNS(null,"transform", "translate("+Map.tileWidth+",0)");
    } else if (angle > 0) {
        var cx = (x + 1.5) * Map.tileWidth; // empty column to the left
        var cy = (y + 1.5) * Map.tileWidth; // empty row at the top
        tile.setAttributeNS(null,"transform", "rotate("+angle+","+cx+","+cy+")");
    } else {
        tile.removeAttributeNS(null,"transform");
    }
}
      
function wall(x, y, type) {
    var now = new Date();
    if (Pen.type===type && Map.walls[x][y] != null && Pen.ts && now - Pen.ts <= 2000) {
        // we just placed a door: take the last one and rotate it
        var tile = Map.walls[x][y][Map.walls[x][y].length - 1];
        var old = tile.getAttributeNS(null,"transform");
        var angle = parseInt(tile.getAttribute("rotate"));
        var rotate = wall_rotation(x, y, (angle + 90) % 360);
        if (rotate != null) {
            Commands.push(
                function(){
                    rotate_tile(tile, type, x, y, angle);
                },
                function(){
                    rotate_tile(tile, type, x, y, rotate);
                });
        }
    } else {
        // make sure the data structure exists
        if (!Map.walls[x][y]) {
            Map.walls[x][y] = [];
        }
        var rotate = wall_rotation(x, y, 0);
        if (rotate != null) {
            var tile = create_tile(x, y, type);
            rotate_tile(tile, type, x, y, rotate);
            Commands.push(
                function(){
                    remove_wall (x, y);
                },
                function(){
                    Map.walls[x][y].push(tile);
                    Map.wallsElement.appendChild(tile);
                });
        }
    }
    Pen.ts = now;
}

function remove_wall (x, y) {
    if (Map.walls[x][y] != null) {
        // take the last one and remove it
        var tile = Map.walls[x][y].pop();
        Map.wallsElement.removeChild(tile);
        // don't clean up if Map.walls[x][y].length == 0 because of
        // redo
    }
}

function door(x, y) {
    wall(x, y, "door");
    Pen.type = "door";
}

function secret(x, y) {
    wall(x, y, "secret");
    Pen.type = "secret";
}

function concealed(x, y) {
    wall(x, y, "concealed");
    Pen.type = "concealed";
}

function gate(x, y) {
    wall(x, y, "gate");
    Pen.type = "gate";
}

function trap(x, y) {
    var old = Map.floor[x][y];
    if (old != null && old.type==="trap") {
        floor(x, y);
    } else {
        var stair = Map.stairs[x][y];
        var tile = create_tile(x, y, "trap");
        Commands.push(
            function(){
                Map.floorElement.removeChild(tile);
                if (old != null) {
                    Map.floorElement.appendChild(old);
                }
                Map.floor[x][y] = old;
                if (stair != null) {
                    Map.stairsElement.appendChild(stair);
                    Map.stairs[x][y] = stair;
                }
            },
            function(){
                if (stair != null) {
                    Map.stairsElement.removeChild(stair);
                    Map.stairs[x][y] = null;
                }
                if (old != null) {
                    Map.floorElement.removeChild(old);
                }
                Map.floor[x][y] = tile;
                Map.floorElement.appendChild(tile);
            });
    }
}

function stairs(x, y) {
    if (Map.stairs[x][y] != null) {
        var tile = Map.stairs[x][y];
        var angle = parseInt(tile.getAttribute("rotate"));
        Commands.push(
            function(){
                rotate_tile(tile, "stairs", x, y, angle);
            },
            function() {
                rotate_tile(tile, "stairs", x, y, (angle + 90) % 360);
            });
    } else {
        var tile = create_tile(x, y, "stair");
        tile.setAttribute("rotate", 0);
        Commands.push(
            function(){
                Map.stairsElement.removeChild(tile);
                Map.stairs[x][y] = null;
            },
            function(){
                Map.stairs[x][y] = tile;
                Map.stairsElement.appendChild(tile);
            });
    }
}

function floor(x, y) {
    var stair = Map.stairs[x][y];
    var old   = Map.floor[x][y];
    var tile  = create_tile(x, y, "empty");
    if (stair != null || old == null || old.type != "empty") {
        Commands.push(
            function(){
                if (stair != null) {
                Map.stairsElement.appendChild(stair);
                    Map.stairs[x][y] = stair;
                }
                Map.floorElement.removeChild(tile);
                if (old != null) {
                    Map.floorElement.appendChild(old);
                }
                Map.floor[x][y] = old;
            },
            function(){
                if (stair != null) {
                    Map.stairsElement.removeChild(stair);
                    Map.stairs[x][y] = null;
                }
                if (old != null) {
                    Map.floorElement.removeChild(old);
            }
                Map.floorElement.appendChild(tile);
                Map.floor[x][y] = tile;
            });
    }
}

/* This is where we draw (or erase) floor tiles. The key point to
 * remember is that we might not get a mouse event for every
 * coordinate. That's why we need to store where we want to draw to
 * (our target) and start drawing at our current position (the pen).
 * We do this at least once in order to support clicks without mouse
 * movement. Then we start a loop: as long as the pen hasn't reached
 * the target, we change x or y by 1 and draw another tile. As we're
 * creating closures for Commands, we need to do this in a factory.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Creating_closures_in_loops.3A_A_common_mistake
 */

function draw_to_command(x, y, tile, type) {
    var remove = function(){
            Map.floorElement.removeChild(tile);
            Map.floor[x][y] = null;
    };
    var add = function(){
            Map.floor[x][y] = tile;
            Map.floorElement.appendChild(tile);
    };
    if (type == "add") {
        Commands.push(remove, add); // add new tile
    } else {
        Commands.push(add, remove); // remove existing tile
    }
}

function draw_to(evt) {
    var target = Pen.position(evt);
    // draw up to the current position (at least once if we just started)
    do {
        if (Map.floor[Pen.x][Pen.y] == null && Pen.type == "empty") {
            draw_to_command(Pen.x, Pen.y, create_tile(Pen.x, Pen.y, "empty"), "add");
        } else if (Map.floor[Pen.x][Pen.y] != null && Pen.type == "null") {
            draw_to_command(Pen.x, Pen.y, Map.floor[Pen.x][Pen.y], Pen.type, "remove");
        }
    } while (Pen.move_to(target));
    pen_track(evt);
}

/* When we're drawing (draw_to), the position of the pen is always
 * updated. When we're not drawing, we still need to store something
 * because of possible keypress events (which don't come with a
 * position). Simply storing the event seems to be the cheapest
 * option. */

function pen_track(evt) {
    Pen.evt = evt;
} 

/* When setting down the pen (onmousedown, pen_down), we look at the
 * current tile. If it's the empty floor tile, we'll want to erase it.
 * If there is no floor tile (null), we'll want to draw an empty floor
 * tile. We store this information in the Pen type and as we keep on
 * drawing (onmousemove, draw_to), we don't change it. */

function pen_down(evt) {
    Pen.update();
    if (Map.floor[Pen.x][Pen.y] != null) {
        Pen.type = "null";
    } else {
        Pen.type = "empty";
    }
    // draw at least one tile
    draw_to(evt);
    // install new handler
    Map.ui.onmousemove = draw_to;
    // revert to pen tracking on mouse up *anywhere*
    document.onmouseup = function() {
        Map.ui.onmousemove = pen_track;
    }
}

/* Many of the key commands need a "current" position. We determine it
 * by looking at the Pen. It's position is always tracked (onmousemove,
 * pen_track). */

function key_pressed(evt) {
    var key = evt.key;

    //Google Chrome
    if(!key && evt.keyIdentifier) {
        if (evt.keyIdentifier.substring(0,2) == "U+") { // U+0044 = D
            key = String.fromCharCode(parseInt(event.keyIdentifier.substr(2), 16));
            if (!evt.shiftKey) {
                key = key.toLowerCase(); // "D" to "d"
            }
        } else {
            key = evt.keyIdentifier; // "Left"
        }
    }

    if(key==="?") {
        var help = document.getElementById("help");
        if (help.getAttributeNS(null, "visibility") == "hidden") {
            help.setAttributeNS(null, "visibility", "visible");
        } else {
            help.setAttributeNS(null, "visibility", "hidden");
        }
    } else if (key == "ArrowDown" || key == "Down") { move_down();
    } else if (key == "ArrowUp" || key == "Up")   { move_up();
    } else if (key == "ArrowLeft" || key == "Left") { move_left();
    } else if (key == "ArrowRight" || key == "Right") { move_right();
    } else if (key==="u") {
        Commands.undo();
    } else if (key==="r") {
        Commands.redo();
    } else if (Pen.evt) {
        Pen.update();
        if (key==="d") {
            door(Pen.x, Pen.y);
        } else if (key==="s") {
            secret(Pen.x, Pen.y);
        } else if (key==="c") {
            concealed(Pen.x, Pen.y);
        } else if (key==="g") {
            gate(Pen.x, Pen.y);
        } else if (key==="w") {
            remove_wall(Pen.x, Pen.y);
        } else if (key==="t") {
            trap(Pen.x, Pen.y);
        } else if (key==="l") {
            stairs(Pen.x, Pen.y);
        } else if (key==="f") {
            floor(Pen.x, Pen.y);
        }
    }
}

function recreate_model_for(re, model, element) {
    for (var i = 0; i < element.children.length; i++) {
        var result = element.children[i].getAttribute("id").match(re);
        if (result) {
            var x = result[1];
            var y = result[2];
            model[x][y] = element.children[i];
        }
    }
}

function recreate_model() {
    var re = /^\w+_(\d+)_(\d+)$/;
    recreate_model_for(re, Map.floor, Map.floorElement);
    recreate_model_for(re, Map.stairs, Map.stairsElement);
    // doors are a special case because of the array
    for (var i = 0; i < Map.wallsElement.children.length; i++) {
        var result = Map.wallsElement.children[i].getAttribute("id").match(re);
        if (result) {
            var x = result[1];
            var y = result[2];
            // make sure the data structure exists
            if (!Map.walls[x][y]) {
                Map.walls[x][y] = [];
            }
            Map.walls[x][y].push(Map.wallsElement.children[i]);
        }
    }
}
      
function initialize() {
    scale_tiles();
    var scale = Map.tileWidth / 20;
    var background = document.getElementById("background");
    resize(background,
           Map.width * Map.tileWidth,
           Map.height * Map.tileWidth,
           linear);
    move(background,
         // an empty column to the left
         Map.tileWidth - background.getAttribute("x"),
         // an empty column at the top
         Map.tileWidth - background.getAttribute("y"),
         linear);
    var help = document.getElementById("help");
    if (scale != 1) {
        // from now on, we need to scale all coordinates!
        help.setAttribute("transform", "scale("+scale+","+scale+")");
    }
    move(help,
         // an empty column, the background, and another empty column to the left
         (Map.width + 2) * Map.tileWidth / scale - help.firstElementChild.getAttribute("x"),
         // an empty column at the top
         Map.tileWidth / scale - help.firstElementChild.getAttribute("y"),
         bounceEaseOut);
    Map.ui = document.getElementById("ui");
    Map.ui.setAttribute("x", Map.tileWidth);
    Map.ui.setAttribute("y", Map.tileWidth);
    Map.ui.setAttribute("width",  Map.width * Map.tileWidth);
    Map.ui.setAttribute("height", Map.height * Map.tileWidth);
    Map.floorElement = document.getElementById("floor");
    Map.wallsElement = document.getElementById("walls");
    Map.stairsElement = document.getElementById("stairs");
    // http://javascript.info/tutorial/mouse-events#drag-n-drop
    Map.ui.ondragstart = function() { return false };
    Map.ui.onmousedown = pen_down;
    Map.ui.onmousemove = pen_track;
    document.onkeydown = key_pressed; // capture arrow keys
    for (var x = 0; x < Map.width; x++) {
        Map.floor[x] = [];
        Map.walls[x] = [];
        Map.stairs[x] = [];
    }
    recreate_model();
}

onload = initialize;
]]></script>
  <defs>
    <rect id="cursor" width="10" height="10" fill="white" stroke="black" stroke-width="1" opacity="0.2"/>
    <rect id="empty" width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
    <g id="door" width="10">
      <rect x="-1.5" y="2" width="3" height="6" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="secret" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -2,1 -3,5 0,5 S 2,9 -2,7" />
    </g>
    <g id="concealed" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -3,1 -3,9 2,7" />
    </g>
    <g id="gate" width="10">
      <rect x="-2" y="4" width="4" height="12" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="trap" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="white" stroke="black" stroke-width="1"/>
      <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair" width="10">
      <rect width="10" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="0" y1="3" x2="10" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="1" y1="6" x2="9" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="9" x2="8" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="12" x2="7" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="15" x2="6" y2="15" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="curved-arrow">
      <path fill="none" stroke="forestgreen" stroke-width="1" d="M 0,30 C 0,9 9,0 30,0" />
      <path fill="forestgreen" d="M 23,5 L 30,0 23,-5 Z" />
    </g>
  </defs>
  <rect id="background" x="20" y="20" width="0" height="0" fill="lightgray" stroke="black" stroke-width="1"/>
  <g id="floor"/>
  <g id="stairs"/>
  <g id="walls"/>
  <rect id="ui" opacity="0"/>
  <style><![CDATA[
text { font: 14px 'Courier New', Courier, monospace; }
.key { fill: forestgreen; font-weight: bold; }
]]></style>
  <g id="help">
    <rect x="10" y="80" width="400" height="420" fill="ivory" stroke="black" stroke-width="1"/>
    <use x="20" y="90" xlink:href="#empty"/>
    <text x="50" y="105">Use the mouse to draw and erase the floor</text>
    <use x="20" y="120" xlink:href="#trap"/>
    <text x="50" y="135"><tspan class="key">t</tspan> : a trap, repeat to remove</text>
    <use x="20" y="150" xlink:href="#empty"/>
    <use x="20" y="150" xlink:href="#door"/>
    <text x="50" y="165"><tspan class="key">d</tspan> : a door, repeat to rotate</text>
    <use x="20" y="180" xlink:href="#empty"/>
    <use x="20" y="180" xlink:href="#secret"/>
    <text x="50" y="195"><tspan class="key">s</tspan> : a secret door, repeat to rotate</text>
    <use x="20" y="210" xlink:href="#empty"/>
    <use x="20" y="210" xlink:href="#concealed"/>
    <text x="50" y="225"><tspan class="key">c</tspan> : a concealed door, repeat to rotate</text>
    <use x="20" y="240" xlink:href="#empty"/>
    <use x="20" y="260" xlink:href="#empty"/>
    <use x="20" y="240" xlink:href="#gate"/>
    <text x="50" y="255"><tspan class="key">g</tspan> : a gate, repeat to rotate</text>
    <g>
      <use x="350" y="250" xlink:href="#empty" opacity="0.3"/>
      <use x="330" y="270" xlink:href="#empty" opacity="0.3"/>
      <use x="370" y="270" xlink:href="#empty" opacity="0.3"/>
      <use x="350" y="290" xlink:href="#empty" opacity="0.3"/>
      <use x="350" y="270" xlink:href="#empty"/>
      <rect x="346" y="278" width="8" height="24" fill="olive" stroke="black" stroke-width="2"/>
      <use x="350" y="270" transform="rotate(90,360,280)" xlink:href="#gate"/>
      <use x="350" y="270" transform="rotate(180,360,280)" xlink:href="#gate"/>
      <use x="350" y="270" transform="rotate(270,360,280)" xlink:href="#gate"/>
      <text x="315" y="285" style="fill: olive; font-weight: bold;">1</text>
      <text x="355" y="245" class="key">2</text>
      <text x="395" y="285" class="key">3</text>
      <text x="355" y="325" class="key">4</text>
      <use x="320" y="240" xlink:href="#curved-arrow"/>
      <use x="320" y="240" xlink:href="#curved-arrow" transform="rotate(90,360,280)"/>
      <use x="320" y="240" xlink:href="#curved-arrow" transform="rotate(180,360,280)"/>
      <use x="320" y="240" xlink:href="#curved-arrow" transform="rotate(270,360,280)"/>
    </g>
    <use x="20" y="290" xlink:href="#stair"/>
    <text x="50" y="305"><tspan class="key">l</tspan> : stairs, repeat to rotate</text>
    <text y="350">
      <tspan x="50"><tspan class="key">f</tspan> : floor, remove traps and stairs</tspan>
      <tspan x="50" dy="20"><tspan class="key">w</tspan> : remove gates and all kinds of doors</tspan>
      <tspan x="50" dy="20" class="key">u</tspan><tspan> : undo</tspan>
      <tspan x="50" dy="20" class="key">r</tspan><tspan> : redo</tspan>
      <tspan x="50" dy="20" class="key">?</tspan><tspan> : toggle help</tspan>
      <a fill="blue" xlink:href="https://github.com/kensanata/gridmapper">
        <tspan x="50" dy="40">Source available</tspan>
      </a>
      <a id="download" fill="blue" xlink:href="javascript:download()">
        <tspan x="50" dy="20">Prepare Download</tspan>
      </a>
    </text>
  </g>
</svg>
