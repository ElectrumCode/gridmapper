<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <desc>Gridmapper, a simple tool to create dungeon maps</desc>

  <script type="application/javascript"><![CDATA[

/* The original author (Alex Schroeder) has dedicated Gridmapper to
 * the public domain by waiving all of his rights to the work
 * worldwide under copyright law, including all related and
 * neighboring rights, to the extent allowed by law.
 *
 * More information: http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Code style:
 * https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml */

/* These two constants are used when creating new SVG elements and the
 * href attribute linking them to each other.
 */

var svgNs      = 'http://www.w3.org/2000/svg';
var xlinkNs    = 'http://www.w3.org/1999/xlink';
var inkscapeNs = 'http://www.inkscape.org/namespaces/inkscape';
var xhtmlNs    = 'http://www.w3.org/1999/xhtml';
var wikiUrl    = 'https://campaignwiki.org/wiki/Gridmapper';
var serverUrl  = 'https://campaignwiki.org/gridmapper-server';
var wsUrl      = 'wss://campaignwiki.org/gridmapper-server';

/**
 * Stores everything about the map. The element members point to the
 * SVG elements where we'll be adding stuff. We need multiple elements
 * because that's how we make sure that they are painted in the
 * correct order -- a sort of primitive z-axis. The ui Element is a
 * transparent overlay where we'll register the mouse event handlers.
 *
 * If you want to change the size of the map, simply change width and
 * height. 30x30 was the template for the first One Page Dungeon
 * Contest. The tileWidth is the size of one square, in pixels. You
 * can change that as well.
 */
var Map = {
  width: 30, // how many columns
  height: 30, // how many rows
  tileWidth: 20, // tile size in pixels
  ui: null, // the SVG element with the event handlers
  pointer: null, // the SVG element for the current position
  levelsElement: null, // the SVG element for levels
  levels: [], // data array of level data (Tiles)
  level: 0, // the current level
  data: null, // the current level data (Tiles)
  floorElement: null, // the SVG element for the floor of the current level
  wallsElement: null, // the SVG element for the walls of the current level
  labelsElement: null, // the SVG element for the labels of the current level
  hideOthers: false, // are the other levels hidden?
  lastUrl: null, // last URL loaded
  lastEtag: null, // last etag received
  username: null, // the name of the user (after saving to the wiki)
  websocket: null, // the websocket used to host or listen
  joined: false, // true when a map is joined (no input)
  hosting: false, // true when a map is hosting
  quit: false, // true when quitting to supress extra Chrome message

  /**
   * Initializes the datastructures if necessary. We only need to run
   * this at the very beginning. This does not reset the map in case
   * we're loading an existing file.
   *
   * Mouse and touch events: When we move the mouse (mousemove,
   * touchmove), we call Pen.update to move the pointer. When we click
   * the mouse (mousedown, touchstart), we call penDown. This changes
   * what happens when we move the mouse. Moving the mouse now calls
   * drawTo. When we end our move, we change back: Moving the mouse
   * now calls Pen.update again.
   *
   * When we run the demo, all four event handlers are set to null.
   * When the demo ends, we listen for mousedown and touchstart again.
   */
  initialize: function() {
    Map.pointer = document.getElementById('pointer');
    Map.levelsElement = document.getElementById('levels');
    // http://javascript.info/tutorial/mouse-events#drag-n-drop
    Map.ui = document.getElementById('ui'); // will be moved, too
    Map.ui.ondragstart = function() { return false };
    Map.enable();
    // cannot load or save unless sharing the domain!
    if (window.location.hostname !== 'campaignwiki.org'
        && window.location.hostname !== 'localhost') {
      disableLink(document.getElementById('load'));
      disableLink(document.getElementById('save'));
    }
    // http://javascript.info/tutorial/keyboard-events
    Map.exportarea = document.getElementById('exportarea');
    Map.labelfield = document.getElementById('label');
    Map.symbolInit();
  },

  /**
   * Enable editing on the map.
   */
  enable: function() {
    Map.ui.onmousemove = Pen.update;
    Map.ui.ontouchend = Pen.update;
    Map.ui.onmousedown = penDown;
    Map.ui.ontouchstart = penDown;
    document.onkeydown = keyPressed; // capture arrow keys
    document.onkeypress = keyPressed; // capture character keys
  },

  /**
   * Disable editing on the map.
   */
  disable: function() {
    Map.ui.onmousemove = null;
    Map.ui.ontouchend = null;
    Map.ui.onmousedown = null;
    Map.ui.ontouchstart = null;
    document.onkeydown = null; // capture arrow keys
    document.onkeypress = null; // capture character keys
  },
  
  /**
   * Reset the map. This collects the minimum we need to clean
   * everything up. We run this code before starting the demo, for
   * example. There is no undo.
   */
  reset: function() {
    Commands.reset();
    Pen.reset();
    while (Map.levelsElement.lastChild) 
      Map.levelsElement.removeChild(Map.levelsElement.lastChild);
    Map.levels = [];
    createLevel(0);
    Map.setLevel(0);
    Map.showLevelAnimation(0);
    moveElements();
  },
  
  /**
   * Grows the data structures along the x axis, if necessary.
   * Animate the process.
   */
  growWithAnimation: function(to_x) {
    if (to_x >= Map.width) {
      Map.width = to_x + 1;
      moveElements();
    }
  },

  /**
   * Sets the current level. Use this when interpreting code.
   */
  setLevel: function(z) {
    if (!Map.levels[z]) {
      createLevel(z);
    }
    Map.level = z;
    Map.floorElement = document.getElementById('floor' + z);
    Map.wallsElement = document.getElementById('walls' + z);
    Map.labelsElement = document.getElementById('labels' + z);
    Map.data = Map.levels[z];
    document.getElementById('level').textContent = z < 665 ? z + 1: 'The End';
    resizeSVG ();
  },

  /**
   * Switch to the indicated level, slowly. This is what we call when
   * the user wants to change level. Usually to_z only differs from
   * Map.level by 1.
   */
  show: function(to_z) {
    var from_z = Map.level;
    if (to_z !== from_z) {
      if (to_z > Map.level) {
        Map.level++;
      } else {
        Map.level--;
      }
      Commands.do(
        function() {
          Map.setLevel(from_z);
          Map.showLevelAnimation();
        },
        function() {
          Map.setLevel(Map.level);
          Map.showLevelAnimation();
        });
      // continue if we haven't reached the target
      if (Map.level !== to_z) {
        Map.show(to_z);
      }
    }
  },

  /**
   * Switch to the indicated level, quickly. This is what we call when
   * setting the level from code and when jumping back to 0. But
   * here's the special case: when doing and undoing this, we want to
   * skip the animation. Then call Map.showLevelAnimation, once.
   */
  jump: function(to_z) {
    var from_z = Map.level;
    if (to_z !== from_z) {
      // push without doing
      Commands.push(
        function() {
          Map.setLevel(from_z);
          Map.showLevelAnimation();
        },
        function() {
          Map.setLevel(to_z);
          Map.showLevelAnimation();
        });
      // just do this
      Map.setLevel(to_z);
    }
  },

  /**
   * Shows all the levels as appropriate, with animation.
   */
  showLevelsTs: null,
  showLevelAnimation: function() {
    // animate it, smoothing it out
    var now = new Date();
    var duration = 500;
    if (Map.showLevelsTs !== null && Map.showLevelsTs > now) {
      setTimeout(Map.showLevelAnimation, Map.showLevelsTs - now);
    } else {
      Map.showLevelsTs = now - (- duration);
      for (var z = 0, map = null; map = document.getElementById('level'+z); z++) {
        if (z === Map.level + 2) {
          fadeElementTo(map, 0.1, linear, duration);
        } else if (z === Map.level + 1) {
          fadeElementTo(map, 0.2, linear, duration);
        } else if (z === Map.level) {
          fadeElementTo(map, 1, linear, duration);
        } else if (z === Map.level - 1) {
          fadeElementTo(map, 0.1, linear, duration);
        } else {
          var opacity = map.hasAttribute('opacity') ? Number(map.getAttribute('opacity')) : 1;
          if (opacity !== 0) {
            fadeElementTo(map, 0, linear, duration);
          }
        }
      }
    }
  },

  /**
   * Hide all the other levels.
   */
  hideOtherLevels: function() {
    // animate it
    var duration = 500;
    for (var z = 0, map = null; map = document.getElementById('level'+z); z++) {
      if (z === Map.level) {
        fadeElementTo(map, 1, linear, duration);
      } else {
        var opacity = Number(map.getAttribute('opacity'));
        if (opacity !== 0) {
          fadeElementTo(map, 0, linear, duration);
        }
      }
    }
  },

  /**
   * Lists the replacement for a particular tile type.
   * This mapping must match the functionality of Map.code.
   */
  variants: {
    'stair': 'stair-small',
    'stair-small': 'stair-spiral',
    'stair-spiral': 'stair-big-spiral',
    'stair-big-spiral': 'stair-big',
    'stair-big': 'stair',
    'door': 'secret',
    'secret': 'concealed',
    'concealed': 'gate',
    'gate': 'door',
    'diagonal': 'arc',
    'arc': 'arc2',
    'arc2': 'arc3',
    'arc3': 'diagonal',
    'trap': 'pit',
    'pit': 'trap-door-ceiling',
    'trap-door-ceiling': 'trap-door-floor',
    'trap-door-floor': 'trap-door-secret',
    'trap-door-secret': 'trap',
    'statue': 'well',
    'well': 'fountain',
    'fountain': 'statue',
    'pillar': 'altar',
    'altar': 'dais',
    'dais': 'dais-round',
    'dais-round': 'pillar',
    'wall': 'curtain',
    'curtain': 'portcullis',
    'portcullis': 'wall',
    'chest': 'bed',
    'bed': 'table',
    'table': 'chest',
    'empty': 'void',
    'void': 'water',
    'water': 'empty',
  },

  symbols: null,

  symbolInit: function(){
    var map = {
      door: 'd', wall: 'w', stair: 's', chest: 'c',
      trap: 't', empty: 'f', pillar: 'p', statue: 'b', diagonal: 'n',
    };
    var keys = Object.keys(map);
    for (var i = 0; i < keys.length; i++) {
      var first = keys[i];
      var sym = map[first];
      for (var next = Map.variants[first]; next !== undefined && next !== first; next = Map.variants[next]) {
        sym += 'v';
        map[next] = sym;
      }
    }
    Map.symbols = map;
  },
  
  /**
   * Produces the code necessary to reproduce the map. The characters
   * must be handled by interpretCont and keyPressed.
   */
  code: function() {
    var source = '';
  
    for (var y = 0; y < Map.height; y++) {
      for (var x = 0; x < Map.width; x++) {
        if (Map.data.has(x, y)) {

          var walls = Map.data.get(x, y).walls;
          if (walls) {
            walls = walls.sort(function(a,b){
              return parseInt(a.getAttribute('rotate')) - parseInt(b.getAttribute('rotate'));
            });
            for (var i = 0; i < walls.length; i++) {
              var tile = walls[i];
              var type = Map.symbols[tile.type];
              if (type) {
                source += type[0].repeat(1 + tile.getAttribute('rotate') / 90 - i) + type.substr(1);
              }
              if (i < walls.length - 1)
                source += '.';
            }
          }
          
          // label must precede floor tiles which advance the position
          var label = Map.data.get(x, y).label;
	  if (label !== null) {
	    if (label.textContent.search(/^[0-9]*$/) === 0) {
              source += label.textContent;
            } else {
              source += '"' + label.textContent + '"';
            }
          }
          var tile = Map.data.get(x, y).floor;
          if (tile !== null) {
            if (tile.hasAttribute('rotate')) {
              var rotate = tile.getAttribute('rotate') / 90;
              var type = Map.symbols[tile.type];
              source += type[0].repeat(1 + rotate) + type.substr(1);
            } else {
              source += Map.symbols[tile.type];
            }
            // the only floor tile that auto-advances is the empty floor
            if (tile.type !== 'empty')
              source += ' ';
          } else {
            source += ' ';
          }
        } else {
          source += ' ';
        }
      }
      source += '\n';
    }
    source = source.replace(/ +$/gm,'');
    source = source.replace(/\n+$/,'');
    source = source.replace(/^(\n*)( *)/, function(match, ys, xs) {
      if (match.length > 5) {
        return '(' + xs.length + ',' + ys.length + ')';
      } else {
        return match;
      }
    });
    return source;
  },
};

/**
 * Provides a matrix of Tiles. If you use the get method on
 * coordinates where no Tile exists, a new one will be created.
 */
function Tiles() {
  this.data = [];
};

Tiles.prototype.get = function(x, y) {
  if (!this.data[x]) {
    this.data[x] = [];
  }
  if (!this.data[x][y]) {
    this.data[x][y] = new Tile();
  }
  return this.data[x][y];
}

Tiles.prototype.has = function(x, y) {
  return this.data[x] && this.data[x][y];
}

/**
 * Stores everything about a single square and its surrounding walls.
 */
function Tile() {
  this.floor = null;
  this.walls = [];
  this.label = null;
};

/**
 * Holds information about the mouse. We're trying to keep as much of
 * the coordinate messing to ourselves, here. Remember: there is an
 * empty column to the left and an empty row at the top.
 */
var Pen = {
  x: 0,
  y: 0,
  ts: null, // when was the pen last used to draw a door
  type: null, // type of tile we last used
  dir: null, // last movement

  /**
   * Determines the grid position based on a mouse event and returns
   * it. Remember that Wall Mode has one coordinate + 0.5. Also
   * consider that in Wall mode, we need to find a point where the
   * axis changes, "jump a corner".
   */
  position: function(evt) {
    var x = evt.pageX / Map.tileWidth - 1; // empty column on the left
    var y = evt.pageY / Map.tileWidth - 1; // empty row at the top
    if (Pen.type === 'wallMode') {
      var dx = x % 1;
      var dy = y % 1;
      if (Pen.x % 1 !== 0) {
        // on a vertical wall
        if (dx > 0.3 && dx < 0.7 && (dy > 0.8 || dy < 0.2)) {
          return { x: Math.floor(x + 0.5), y: Math.floor(y) + 0.5 };
        }
        // no jumping
        return { x: Math.floor(x + 0.5) - 0.5, y: Math.floor(y) };
      }
      // on a horizontal wall
      if ((dx > 0.8 || dx < 0.2) && dy > 0.3 && dy < 0.7) {
        // jump to a vertical wall
        return { x: Math.floor(x) + 0.5, y: Math.floor(y + 0.5) };
      }
      // no jumping
      return { x: Math.floor(x), y: Math.floor(y + 0.5) - 0.5 };
    }
    // in a square
    return { x: Math.floor(x), y: Math.floor(y) };
  },

  /**
   * Moves the pointer to the current Pen position. If passed a
   * non-null mouse event, determine the new position, first. We call
   * this onmousemove even if we're not drawing because of possible
   * keypress events (which don't come with a position).
   */
  update: function(evt) {
    if (evt) {
      evt.preventDefault(); /* for touch events: no scrolling */
      var pos = Pen.position(evt);
      if (Pen.x !== pos.x || Pen.y !== pos.y) {
        Pen.ts = null;
        Pen.x = pos.x;
        Pen.y = pos.y;
        record('(' + Pen.x + ',' + Pen.y + ')');
      }
    }
    Map.pointer.setAttribute('x', (Pen.x + 1) * Map.tileWidth);
    Map.pointer.setAttribute('y', (Pen.y + 1) * Map.tileWidth);
  },

  /**
   * Moves the Pen one step closer to the target position. Returns
   * true if the Pen moved, returns false if the Pen is already at
   * the target. As Wall Mode means that one of the coordinates is
   * off by half, this needs special consideration.
   */
  moveTo: function(target) {
    // jump a corner, if necessary
    if (Pen.type === 'wallMode'
        && (Math.abs(Pen.x - target.x) == 0.5
           || Math.abs(Pen.y - target.y) == 0.5)) {
      Pen.x += target.x > Pen.x ? 0.5 : -0.5;
      Pen.y += target.y > Pen.y ? 0.5 : -0.5;
      return true;
    } else if (Pen.x !== target.x) {
      Pen.x += target.x > Pen.x ? 1 : -1;
      return true;
    } else if (Pen.y !== target.y) {
      Pen.y += target.y > Pen.y ? 1 : -1;
      return true;
    }
    return false;
  },

  /**
   * Resets the pen coordinates so that a file can no be loaded
   * safely.
   */
  reset: function() {
    Pen.x = 0;
    Pen.y = 0;
    Pen.type = null;
  },
};

/**
 * Maintains an undo and a redo list. Whenever you do something that
 * the user can undo, you need to call Commands.do with two
 * functions, the how-to-undo-it step and the how-to-do-it step.
 * how-to-do-it will be called once on order to do it. When the user
 * undoes something, our index is decremented and we execute the
 * appropriate undo step. When the user redoes something, our index is
 * incremented and we execute the appropriate redo step. If the user
 * has undone some steps and then pushes new commands, we discard the
 * steps we have undone.
 */
var Commands = {
  i: -1, // where are we in the undo/redo chain
  undoSteps: [],
  redoSteps: [],

  /**
   * Add two closures to the lists. The first one is how to undo a
   * change, the second one is how to do a change.
   */
  push: function(undoStep, redoStep) {
    // once we're pushing new steps, discard the undone steps
    while (this.undoSteps.length - 1 > this.i) {
      this.undoSteps.pop();
      this.redoSteps.pop();
    }
    this.undoSteps.push(undoStep);
    this.redoSteps.push(redoStep);
    this.i++;
  },
  
  /**
   * Add two closures to the lists. The first one is how to undo a
   * change, the second one is how to do a change. This automatically
   * does the change, too.
   */
  do: function(undoStep, redoStep) {
    Commands.push(undoStep, redoStep);
    redoStep();
  },
  
  undo: function() {
    if (this.i >= 0) {
      this.undoSteps[this.i--]();
    }
  },
  
  redo: function() {
    if (this.i < this.redoSteps.length - 1) {
      this.redoSteps[++this.i]();
    }
  },
  
  reset: function() {
    undoSteps = [];
    redoSteps = [];
  }
};

/**
 * The user interface code for running a demo. The actual demo is
 * scripted in SVG element with the 'messages' id. Each step of the
 * element makes the tspan elements with matching class visible. If
 * there is a code element with a matching class, its text content is
 * interpreted as a script.
 */
var Demo = {

  /**
   * Stores the code to be run on a timer.
   */
  running: null,

  /**
   * Stores the element containing all the steps.
   */
  element: null,

  /**
   * Allows the user to run the demo.
   */
  start: function () {
    Demo.link('Reset map and run demo', 'Demo.run()', true);
  },

  /**
   * Changes the demo link to something else.
   */
  link: function (text, js, revert) {
    var link = document.getElementById('demo');
    var oldText = link.firstChild.nodeValue;
    link.firstChild.nodeValue = text;
    var href = link.getAttributeNS(xlinkNs, 'href');
    link.setAttributeNS(xlinkNs, 'href', 'javascript:' + js);
    // reset after 2s
    if (revert)
      var t = setInterval(function() {
        if (!Demo.running) {
          link.setAttributeNS(xlinkNs, 'href', href);
          link.firstChild.nodeValue = oldText;
          clearInterval(t);
        }
      }, 2000);
  },

  /**
   * Demo the application.
   */
  run: function () {
    Map.reset();
    Demo.running = true;
    Demo.link('Click to stop demo', 'Demo.stop()', false);
    Map.disable();
    Demo.element = document.getElementById('messages');
    moveElement(Demo.element,
                Demo.element.getBBox().x,
                Demo.element.getBBox().y,
                3 * Map.tileWidth,
                3 * Map.tileWidth,
                bounceEaseOut);
    Demo.step(1);
  },

  /**
   * Let the demo know that we want to abort.
   */
  stop: function () {
    clearInterval(Demo.running);
    Demo.running = null;
    Demo.clean(null);
    wallModeOff();
    Map.enable();
    Demo.link('Abort! Abort!', 'void', false);
  },

  /**
   * Hides elements from a particular step. Usually called for the previous step.
   */
  clean: function(step) {
    var elements = step
        ? Demo.element.getElementsByClassName('step' + step)
        : Demo.element.childNodes;
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].nodeType === Node.ELEMENT_NODE) // IE 11 has no children
        elements[i].setAttribute('visibility', 'collapse');
    }
  },
  
  /**
   * Demo one step and timeout. Note that it's confusing to have more
   * than one code element per step. These are started in order, but
   * if one of them starts delaying using ';', later code will
   * continue executing.
   */
  step: function (step) {
    Demo.clean(step - 1);
    var wait = 5000;
    // show elements for this step and run its code
    elements = Demo.element.getElementsByClassName('step' + step);
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].nodeName === 'tspan') {
        elements[i].setAttribute('visibility', 'visible');
      } else if (elements[i].nodeName === 'code') {
        var code = elements[i].textContent;
        if (code) {
          // Add a delay for every ';' in the code.
          var z = code.match(/;/g);
          if (z)
            wait += 500 * z.length;
          interpret(code);
        }
      }
    }
    // if there was a step, schedule the next step; else quit
    if (elements.length > 0) {
      Demo.running = setTimeout(function() {
        Demo.step(step + 1);
      }, wait);
    } else {
      Demo.stop();
    }
  },
}

/**
 * Defining repeat for Strings, for Chrome/Mac Version 40.0.2214.111
 * (64-bit) as suggested on
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
 */
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    'use strict';
    if (this == null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count != count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count == Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length == 0 || count == 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (august 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count == 0) {
        break;
      }
      str += str;
    }
    return rpt;
  }
}

/* The animation code is taken from these examples:
 * http://javascript.info/tutorial/animation
 */
function animate (opts) {
  var start = new Date();
  var id = setInterval(function() {
    var timePassed = new Date() - start;
    var progress = timePassed / opts.duration;
    if (progress > 1) progress = 1;
    var delta = opts.delta(progress);
    opts.step(delta);
    if (progress === 1) {
      clearInterval(id);
    }
  }, opts.delay || 10);
}

function linear (progress) {
  return progress;
}

function inverse (progress) {
  return 1 - progress;
}

function bounce (progress) {
  for(var a = 0, b = 1; 1; a += b, b /= 2) {
    if (progress >= (7 - 4 * a) / 11) {
      return -Math.pow((11 - 6 * a - 11 * progress) / 4, 2) + Math.pow(b, 2)
    }
  }
}

function makeEaseOut (delta) {
  return function(progress) {
    return 1 - delta(1 - progress);
  }
}

var bounceEaseOut = makeEaseOut(bounce);

function resizeElement (element, toWidth, toHeight, delta, duration) {
  var fromWidth  = element.getBBox().width;  // assuming px
  var fromHeight = element.getBBox().height; // assuming px
  animate({
    delay: 10,
    duration: duration || 1000, // 1 sec by default
    delta: delta,
    step: function(delta) {
      element.setAttribute('width',  fromWidth  + (toWidth  - fromWidth)  * delta);
      element.setAttribute('height', fromHeight + (toHeight - fromHeight) * delta);
    }
  })
}

function moveElement (element, x1, y1, x2, y2, delta, duration) {
  var re = /translate\(.*?\)/;
  var currentX = element.currentX || x1;
  var currentY = element.currentY || y1;
  var oldDx = currentX - x1;
  var oldDy = currentY - y1;
  var newDx = x2 - currentX;
  var newDy = y2 - currentY;
  element.currentX = x2;
  element.currentY = y2;
  if (newDx !== 0 || newDy !== 0)
    animate({
      delay: 10,
      duration: duration || 1000, // 1 sec by default
      delta: delta,
      step: function(delta) {
        var transform = 'translate(' + (oldDx + newDx * delta) + ',' + (oldDy + newDy * delta) + ')';
        if (!element.hasAttribute('transform'))
          element.setAttribute('transform', transform);
        else if (element.getAttribute('transform').match(re))
          element.setAttribute('transform', element.getAttribute('transform').replace(re, transform));
        else
          element.setAttribute('transform', element.getAttribute('transform') + ',' + transform);
      }
    })
}

function fadeElementTo (element, opacity, delta, duration) {
  var from = element.hasAttribute('opacity') ? Number(element.getAttribute('opacity')) : 1;
  animate({
    delay: 10,
    duration: duration || 1000, // 1 sec by default
    delta: delta,
    step: function(delta) {
      var value = from + (opacity - from) * delta;
      if (value > 0.99) {
        element.removeAttribute('opacity');
      } else {
        element.setAttribute('opacity', value);
      }
    }
  });
};

/**
 * Updates the SVG width and height.
 * This allows browsers to scroll the image.
 */
function resizeSVG () {
  var help = document.getElementById('help').firstElementChild;
  var level = document.getElementById('level');
  document.rootElement.setAttribute(
    'width', (Map.width + 2) * Map.tileWidth // map with + two empty columns
      + Number(help.getAttribute('width'))
      + Number(level.getAttribute('x'))    // distance between help
      - Number(help.getAttribute('x'))     // rectangle and level
      - Number(help.getAttribute('width')) // indicator
      + level.getBBox().width // width of level indicator
  );
  document.rootElement.setAttribute(
    'height', Math.max((Map.height + 2) * Map.tileWidth,
                       2 * Map.tileWidth
                       + Number(help.getAttribute('height'))));
}

/**
 * Moves the elements around if the map dimensions change.
 * Makes sure the UI element covers it all.
 * Moves and resizes the grey background.
 * This should work for a different Map.tileWidth as well!
 */
function moveElements () {
  resizeSVG();
  Map.ui.setAttribute('x', Map.tileWidth);
  Map.ui.setAttribute('y', Map.tileWidth);
  Map.ui.setAttribute('width',  Map.width * Map.tileWidth);
  Map.ui.setAttribute('height', Map.height * Map.tileWidth);
  for (var child = document.getElementById('background').firstElementChild;
       child; child = child.nextElementSibling) {
    resizeElement(child,
                  Map.width * Map.tileWidth,
                  Map.height * Map.tileWidth,
                  linear, 600);
    moveElement(child,
                parseInt(child.getAttribute('x')),
                parseInt(child.getAttribute('y')),
                Map.tileWidth, // an empty column to the left
                Map.tileWidth, // an empty column at the top
                linear, 500);
  }
  var help = document.getElementById('help');
  moveElement(help,
              help.getBBox().x,
              help.getBBox().y,
              // an empty column, the background, and another empty column to the left
              (Map.width + 2) * Map.tileWidth,
              // an empty column at the top
              Map.tileWidth,
              linear, 500);
}

/**
 * Make sure the link element no longer looks like a link.
 */
function disableLink(element) {
  element.setAttribute('style', 'color:grey');
  element.setAttribute('title', 'Your browser prevents this unless you’re loading the script from campaignwiki.org.');
}

/**
 * Offer the current document for download. We store the entire
 * document in a data URI and offer it for downlod using the HTML5
 * download attribute. Chrome 40 will still load that file instead of
 * downloading it. Perhaps a namespace issue? After all, there is no
 * such download attribute for SVG or XHTML.
 */
function download () {

  // hide Prepare Download link and show formats
  document.getElementById('download').setAttribute('display', 'none');
  document.getElementById('format').setAttribute('display', 'inline');

  // revert this change after 10s
  var t = setInterval(function() {
    document.getElementById('download').setAttribute('display', 'inline');
    document.getElementById('format').setAttribute('display', 'none');
    clearInterval(t);
  }, 10000);

  var svg = document.querySelector('svg');

  // SVG download includes user interface
  var source = btoa(unescape(encodeURIComponent(new XMLSerializer().serializeToString(svg))));
  var link  = document.getElementById('download_svg');
  link.setAttributeNS(xlinkNs, 'href', 'data:image/svg+xml;base64,' + source);

  // PNG download hides user interface. We must actually *remove* all
  // the foreignObject elements because it causes a security exception
  // in Safari.
  // http://stackoverflow.com/questions/33972254/svgpng-from-canvas-todataurl-throws-dom-exception-18-security-error-in-safari-9
  var clone = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  var background = svg.getElementById('background');
  clone.setAttribute('width', svg.getAttribute('width'));
  clone.setAttribute('height', svg.getAttribute('width'));
  clone.appendChild(svg.querySelector('defs').cloneNode(true));
  clone.appendChild(svg.getElementById('background').cloneNode(true));
  clone.appendChild(svg.getElementById('levels').cloneNode(true));
  source = btoa(unescape(encodeURIComponent(new XMLSerializer().serializeToString(clone))));

  link  = document.getElementById('download_png');
  
  // SVG to PNG using canvas https://gist.github.com/gustavohenke/9073132
  var canvas = document.createElementNS(xhtmlNs, 'canvas');
  var rect = Map.ui.getBoundingClientRect();
  canvas.width = (Map.width + 2) * Map.tileWidth; // see resizeSVG
  canvas.height = (Map.width + 2) * Map.tileWidth;
  var ctx = canvas.getContext('2d');
  var img = document.createElementNS(xhtmlNs, 'img');
  img.setAttribute('src', 'data:image/svg+xml;base64,' + source);

  // when the image arrived in the canvas, set the link
  img.onload = function() {
    ctx.drawImage(img, 0, 0);
    link.setAttributeNS(xlinkNs, 'href', canvas.toDataURL('image/png'));
  };
}

/**
 * Stores the entire document in a link for the user to click.
 */
function prepareLink () {
  var link = document.getElementById('export');
  var text = link.firstChild.nodeValue;
  link.firstChild.nodeValue = 'Link';
  var href = link.getAttributeNS(xlinkNs, 'href');
  var location = window.location.href.substr(
    0, window.location.href.length - window.location.search.length)
  link.setAttributeNS(xlinkNs, 'href', location + '?' + encodeURIComponent(getSource()));
  // reset after 10s
  var t = setInterval(function() {
    link.setAttributeNS(xlinkNs, 'href', href);
    link.firstChild.nodeValue = text;
    clearInterval(t);
  }, 10000);
}

/**
 * Exports the entire document in the text area.
 */
function textExport () {
  Map.exportarea.value = getSource();
}

/**
 * Exports the code in the text area.
 */
function textImport () {
  interpret(Map.exportarea.value);
  Map.showLevelAnimation();
  Pen.update(null);
}

/**
 * Stores the entire document in a sequence of keystrokes with which
 * to recreate it.
 */
function getSource () {
  // do we need to export the map below
  var source = '';
  var level = Map.level;
  for (var z = 0, map = null; map = document.getElementById('level'+z); z++) {
    if (z > 0)
      source += 'z';
    Map.setLevel(z);
    source += Map.code();
  }
  Map.setLevel(level); // reset
  source = source.replace(/zz+/,'z');
  source = source.replace(/^z+/,'');
  source = source.replace(/z+\w*$/,'');
  source += '(' + Pen.x + ',' + Pen.y + ',' + Map.level + ')\n'; // end with newline
  return source;
}

function message (str) {
  var element = document.createElementNS(svgNs, 'g');
  var rect = document.createElementNS(svgNs, 'rect');
  rect.setAttribute('fill', 'white');
  rect.setAttribute('stroke', 'black');
  rect.setAttribute('stroke-width', '1px');
  rect.setAttribute('x', 2 * Map.tileWidth);
  rect.setAttribute('y', 2 * Map.tileWidth);
  element.appendChild(rect);
  var text = document.createElementNS(svgNs, 'text');
  element.appendChild(text);
  var lines = str.split('\n');
  var len = 0;
  for (var i = 0; i < lines.length; i++) {
    var tspan = document.createElementNS(svgNs, 'tspan');
    len = Math.max(len, lines[i].length);
    tspan.textContent = lines[i];
    tspan.setAttribute('x',  2.5 * Map.tileWidth);
    if (i === 0) {
      tspan.setAttribute('y', 3 * Map.tileWidth);
    } else {
      tspan.setAttribute('dy', Map.tileWidth);
    }
    text.appendChild(tspan);
  }
  rect.setAttribute('width', (2 + len / 2.5) * Map.tileWidth);
  rect.setAttribute('height', (0.5 + lines.length) * Map.tileWidth);
  document.rootElement.appendChild(element);
  var ms = 2000 + 700 * lines.length;
  fadeElementTo(element, 0, linear, ms);
  setTimeout(function(){document.rootElement.removeChild(element);}, ms);
}

/**
 * Saves the map to Campaign Wiki. This is the interactive entry
 * point. It reads title, username and summary from the exportarea
 * multiline text field.
 */
function save () {
  var input = Map.exportarea.value;
  if (input === undefined || input === '') {
    message('Please provide a name for your wiki in this text area!\n'
            + 'Use the first line for the wiki name,\n'
            + 'the second line for your name,\n'
            + 'and the third line for a summary.');
    return;
  }
  var inputs = input.split('\n');
  if (inputs.length > 3) {
    message('Please use text area to provide some information.\n'
            + 'Use the first line for the wiki name,\n'
            + 'the second line for your name,\n'
            + 'and the third line for a summary.');
    return;
  }
  if (inputs[0].search(/^([-,.()'%&?;<> _1-9A-Za-z\u0080-\ufffd]|[-,.()'%&?;<> _0-9A-Za-z\u0080-\ufffd][-,.()'%&?;<> _0-9A-Za-z\u0080-\ufffd]+)$/) !== 0) {
    message('Unfortunately, this name is not a valid wiki page name');
    return;
  }
  saveIt(inputs[0],
         inputs[1] || 'Anonymous',
         inputs[2] || 'Map saved');
}

/**
 * Saves the current dungeon to the wiki. The wiki replies with a
 * redirect. Unfortunately, we cannot prevent XMLHttpRequest from
 * following this redirect. The AJAX stuff is based on
 * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Sending_forms_through_JavaScript#Building_an_XMLHttpRequest_manually
 */
function saveIt (title, username, summary) {
  var data = {
    title: title,
    text: '[[Gridmapper:' + title + ']]: '
      + (summary || '') + '\n{{{\n' + getSource() + '}}}\n',
    username: username,
    summary: summary,
    frodo: 1,
  };
  var XHR = new XMLHttpRequest();
  var urlEncodedData = '';
  var urlEncodedDataPairs = [];
  var name;
  for(name in data) {
    urlEncodedDataPairs.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name]));
  }
  urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');
  XHR.addEventListener('load', function(event) {
    message('Saved');
  });
  XHR.addEventListener('error', function(event) {
    message('Unfortunately the map could not be saved.');
  });
  try {
    XHR.open('POST', wikiUrl);
    XHR.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    XHR.send(urlEncodedData);
  } catch (e) {
    message('This did not work.\n'
            + 'Perhaps you tried to save to the wiki\n'
            + 'without loading the script from the wiki?');
  }
}

/**
 * Shows a drop down box where the user can pick a map from the wiki.
 */
function load () {
  message('Loading maps...');
  var XHR = new XMLHttpRequest();
  XHR.addEventListener('load', loadMenu);
  XHR.addEventListener('error', function(event) {
    message('Unfortunately the maps could not be loaded.');
  });
  try {
    XHR.open('GET', wikiUrl + '?search={{{;context=0');
    XHR.responseType = 'document';
    XHR.send();
  } catch (e) {
    message('This did not work.\n'
            + 'Perhaps you tried to load from the wiki\n'
            + 'without loading the script from the wiki?');
  }
}

/**
 * Shows a menu of all the maps available.
 */
function loadMenu (event) {
  var doc = event.target.responseXML;
  var links = doc.getElementsByClassName('content')[0].getElementsByClassName('local');
  for (var i = links.length - 1; i >= 0; i--) {
    if (links[i].textContent === 'HomePage' || links[i].textContent.indexOf('Comments on ') === 0) {
      links[i].remove();
    }
  }
  var g = document.createElementNS(svgNs, 'g');
  g.setAttribute('class', 'menu');
  var x = 2 * Map.tileWidth, y = 2 * Map.tileWidth;
  var menu = document.createElementNS(svgNs, 'rect');
  menu.setAttribute('x', x);
  menu.setAttribute('y', y);
  var perColumn = Math.min(links.length, Map.height - 2);
  var n = 1;
  menu.setAttribute('width', 10 * Map.tileWidth * Math.ceil(links.length / perColumn));
  menu.setAttribute('height', (0.5 + perColumn) * Map.tileWidth);
  menu.setAttribute('fill', 'white');
  menu.setAttribute('stroke', 'black');
  menu.setAttribute('stroke-width', '1');
  g.appendChild(menu);
  for (var i = 0; i < links.length; i++) {
    var a = document.createElementNS(svgNs, 'a');
    var href = links[i].getAttribute('href');
    a.setAttributeNS(xlinkNs, 'href', 'javascript:loadMap("' + href + '")');
    var text = document.createElementNS(svgNs, 'text');
    text.setAttribute('x', x + 10);
    text.setAttribute('y', y + 17);
    text.setAttribute('fill', 'blue');
    text.textContent = links[i].textContent.substr(0,20);
    if (links[i].textContent.length > 20)
      text.textContent += '…';
    a.appendChild(text);
    g.appendChild(a);
    var rect = document.createElementNS(svgNs, 'rect');
    rect.setAttribute('x', x);
    rect.setAttribute('y', y);
    rect.setAttribute('width', 10 * Map.tileWidth);
    rect.setAttribute('height', Map.tileWidth);
    rect.setAttribute('fill', 'white');
    rect.setAttribute('opacity', '0');
    a.appendChild(rect);
    if (n++ < perColumn) {
      y += Map.tileWidth;
    } else {
      n = 1;
      y = 2 * Map.tileWidth;
      x += 10 * Map.tileWidth;
    }
  }
  document.rootElement.appendChild(g);
  var ms = 5000 + 500 * links.length;
  var t1 = setTimeout(function(){fadeElementTo(g, 0, linear, ms - 5000);}, 5000);
  var t2 = setTimeout(function(){document.rootElement.removeChild(g);}, ms);
  g.onclick = function(evt) {
    clearTimeout(t1);
    clearTimeout(t2);
    document.rootElement.removeChild(g);
  }
}

/**
 * Loads map from the wiki page.
 */
function loadMap(url) {
  var XHR = new XMLHttpRequest();
  XHR.addEventListener('load', loadIt);
  XHR.addEventListener('error', function(event) {
    message('Unfortunately the map could not be loaded.');
  });
  try {
    XHR.open('GET', url);
    XHR.responseType = 'document';
    if (Map.lastUrl === url) {
      XHR.setRequestHeader('if-none-match', Map.lastEtag);
    }
    XHR.send();
  } catch (e) {
    message('This did not work.\n'
            + 'Perhaps you tried to load a map\n'
            + 'without loading the script from the wiki?');
  }
}

/**
 * Extract map from the wiki content.
 */
function loadIt (event) {
  if (event.target.status === 304) {
    message('Map unchanged...');
    return;
  }
  var doc = event.target.responseXML;
  var pre = doc.getElementsByTagNameNS(xhtmlNs, 'pre')[0];
  if (pre === undefined) {
    message('Unfortunately this link\n'
            + 'contains no map.');
  } else {
    message('Loading');
    Map.reset();
    Map.lastEtag = event.target.getResponseHeader('etag');
    Map.lastUrl = doc.URL;
    var map = pre.textContent.replace('✎', '');
    if (Map.hosting) {
      Map.hosting = false;
      interpret(map);
      Map.hosting = true;
      record('\01' + map + '\03'); // send in a single message
    } else {
      interpret(map);
    }
    Map.showLevelAnimation();
    Pen.update(null);
    var username = '';
    var cookie = event.target.responseXML.cookie;
    var match = decodeURIComponent(decodeURIComponent(cookie)).match(/\bWiki=([^;]*)/);
    if (match !== null) {
      var array = match[1].split('\x1e');
      var i = array.indexOf('username');
      if (i >= 0) {
        username = array[i + 1];
      }
    }
    var h1 = doc.getElementsByTagNameNS(xhtmlNs, 'h1')[0];
    Map.exportarea.value = h1.textContent + '\n' + username + '\n';
  }
}

/**
 * Hosts a map on Campaign Wiki. It reads the map name from the
 * exportarea multiline text field. Information is sent via record.
 */
function host () {
  var input = Map.exportarea.value.trim();
  if (input === undefined || input === '' || input.split('\n').length > 1) {
    message('Please provide a name for your map in the text area!');
    return;
  }
  if (Map.websocket !== null) {
    Map.websocket.close();
  }
  Map.websocket = new WebSocket(wsUrl + '/draw/' + encodeURIComponent(input));
  Map.websocket.onopen = function(evt) {
    Map.hosting = true;
    message('Hosting ' + input);
    document.getElementById('join').setAttribute('class', 'invisible');
    var link = document.getElementById('host');
    link.firstChild.nodeValue = 'Cancel Hosting';
    link.setAttributeNS(xlinkNs, 'href', 'javascript:stop()');
  };
  Map.websocket.onclose = function(evt) {
    Map.hosting = false;
    message('Stopped hosting');
  };
  Map.websocket.onmessage = function(evt) {
    if (evt.data === 'reset') {
      Map.websocket.send('\02' + getSource() + '\03');
    } else {
      console.log('Ignoring message from host: ' + evt.data);
    }
  };
  Map.websocket.onerror = function(evt) {
    if (Map.websocket.readyState === WebSocket.OPEN) {
      message('Hosting error: ' + evt.data);
    }
  };
}

function stop () {
  record('\04');
  if (Map.websocket !== null) {
    Map.websocket.close();
  }
  message('Stopped Hosting');
  document.getElementById('join').setAttribute('class', 'blue');
  var link = document.getElementById('host');
  link.firstChild.nodeValue = 'Host';
  link.setAttributeNS(xlinkNs, 'href', 'javascript:host()');
}

/**
 * Join a hosted map on Campaign Wiki. It reads the map name from the
 * exportarea multiline text field.
 */

function join () {
  var map = Map.exportarea.value.trim();
  if (map === undefined || map === '' || map.split('\n').length > 1) {
    message('Please provide the name of a hosted map in the text area!');
    return;
  }
  if (Map.websocket !== null) {
    Map.websocket.close();
  }
  Map.websocket = new WebSocket(wsUrl + '/join/' + encodeURIComponent(map));
  Map.websocket.onopen = function(evt) {
    message('Joined ' + map);
    Map.reset();
    Map.showLevelAnimation();
    Pen.update(null);
    Map.disable();
    Map.joined = true;
    Map.quit = false;
    document.getElementById('host').setAttribute('class', 'invisible');
    var link = document.getElementById('join');
    link.firstChild.nodeValue = 'Leave Map';
    link.setAttributeNS(xlinkNs, 'href', 'javascript:leave()');
    Map.websocket.send('reset');
  };
  Map.websocket.onclose = null; // ignore?
  Map.websocket.onmessage = function(evt) {
    interpretCont(evt.data, 0); // skip the test for Map.joined in interpret()
  };
  Map.websocket.onerror = function(evt) {
    if (Map.websocket.readyState === WebSocket.OPEN) {
      message('Network error: ' + evt.data);
    } else if (!Map.quit) {
      message('Nobody is hosting ' + map);
    }
  };
}

function leave () {
  if (Map.websocket.readyState === WebSocket.OPEN) {
    Map.websocket.close();
    message('Left map');
  }
  Map.joined = false;
  Map.quit = true;
  Map.enable();
  document.getElementById('host').setAttribute('class', 'blue');
  var link = document.getElementById('join');
  link.firstChild.nodeValue = 'Join';
  link.setAttributeNS(xlinkNs, 'href', serverUrl);
}

/**
 * Record all commands for hosting. This is not the same as the
 * command undo/redo history! Recorded commands are sent to the
 * websocket if were're connected and we're not listening instead.
 */
function record (key) {
  if (Map.hosting && Map.websocket !== null
      && Map.websocket.readyState === WebSocket.OPEN) {
    Map.websocket.send(key);
  }
}

/**
 * Scales all the tiles in the defs element of the SVG. You can add
 * more tiles at whatever scale you want and this code will determine
 * the scale by comparing your tile's width with the tile width in use
 * by the map. The original tiles are all based on a 10x10 grid and
 * are scaled up to 20x20, for example. The easiest way to do this is
 * to use a <g> element and give it an appropriate width attribute.
 * For some user agents such as the iPad Pro, we might want to adjust
 * the tile size to get a better user experience. I wonder...
 */
function scaleTiles () {
  if (navigator.userAgent.match(/iPad/i)) {
    Map.tileWidth = 15; // instead of 20
  }
  var tiles = document.getElementsByTagName('defs')[0].childNodes;
  for (var i = 0; i < tiles.length; ++i) {
    if (tiles[i].nodeType === Node.ELEMENT_NODE
        && tiles[i].hasAttribute('width')) {
      var scale = Map.tileWidth / tiles[i].getAttribute('width');
      if (scale !== 1) {
        tiles[i].setAttribute('transform', 'scale('+scale+','+scale+')');
      }
    }
  }
}

/**
 * Creates a new tile. These tiles are use elements in the SVG
 * referring to an existing definition of the given type. An
 * appropriate id attribute is also generated.
 */
function createTile (x, y, type) {
  var tile = document.createElementNS(svgNs, 'use');
  tile.setAttribute('id', type + '_' + x + '_' + y);
  tile.setAttribute('x', (x + 1) * Map.tileWidth); // empty column to the left
  tile.setAttribute('y', (y + 1) * Map.tileWidth); // empty row at the top
  tile.type = type;
  tile.setAttributeNS(xlinkNs, 'href', '#' + type);
  return tile;
}

/**
 * Add s to the label at (x,y).
 */
function addToLabel(x, y, s) {
  setLabel(x, y, s, true); // append
}

/**
 * Sets the label at (x, y) to s, or appends to the existing label.
 */
function setLabel (x, y, s, append) {
  var tile = Map.data.get(x, y).label;
  var text = null;
  var old = null;
  if (tile === null) {
    tile = document.createElementNS(svgNs, 'text');
    tile.setAttribute('id', 'label' + '_' + x + '_' + y);
    tile.setAttribute('x', (x + 1.5) * Map.tileWidth); // empty column to the left
    tile.setAttribute('y', (y + 1.7) * Map.tileWidth); // empty row at the top, + lineheight
    text = tile.textContent;
  } else {
    old = tile.textContent;
  }
  Commands.do(
    function(){
      tile.textContent = old;
      if (old === null) {
        Map.labelsElement.removeChild(tile);
        Map.data.get(x, y).label = null;
      }
    },
    function(){
      if (text === '') {
        Map.labelsElement.appendChild(tile);
        Map.data.get(x, y).label = tile;
      }
      if (append) {
        tile.textContent += s;
      } else {
        tile.textContent = s;
      }
    });
}

/**
 * Shows the input field at (x,y).
 */
function showLabelField (x, y) {
  fadeElementTo(Map.labelfield, 1, linear, 500);
  Map.labelfield.setAttribute('x', (x + 1) * Map.tileWidth);
  Map.labelfield.setAttribute('y', (y + 1) * Map.tileWidth);
  var tile = Map.data.get(x, y).label;
  setTimeout(function(){
    // on Chrome, the text field will start with " or l from the second event
    Map.labelfield.firstElementChild.value = tile ? tile.textContent : '';
  }, 1);
  Map.labelfield.firstElementChild.focus();
}

function hideLabelField () {
  fadeElementTo(Map.labelfield, 0, linear, 500);
  Map.labelfield.firstElementChild.blur();
  // move it out of the way after waiting for it to fade
  setTimeout(function(){
    Map.labelfield.setAttribute('x', 0);
    Map.labelfield.setAttribute('y', 0);
  }, 500);
}

/**
 * Saves the text in the input field at (x, y).
 */
function saveLabel () {
  hideLabelField();
  setLabel(Pen.x, Pen.y, Map.labelfield.firstElementChild.value, false);
}
  
/**
 * Remove the last character from the label at (x,y).
 * Returns true if there was text to delete.
 */
function deleteFromLabel(x, y) {
  var tile = Map.data.get(x, y).label;
  if (tile !== null) {
    var text = tile.textContent;
    if (text !== '') {
      Commands.do(
        function(){
          if (text.length === 1) {
            Map.labelsElement.appendChild(tile);
            Map.data.get(x, y).label = tile;
          }
          tile.textContent = text;
        },
        function(){
          tile.textContent = tile.textContent.substr(0, tile.textContent.length - 1);
          if (tile.textContent === '') {
            Map.labelsElement.removeChild(tile);
            Map.data.get(x, y).label = null;
          }
        });
      return true;
    }
  }
}

/**
 * Returns an unused angle for wall tiles. Provide a preferred angle.
 * Possible values are 0, 90, 180, 270.
 */
function getUnusedAngle (x, y, rotate) {
  var candidate = [rotate,
                   (rotate + 90) % 360,
                   (rotate + 180) % 360,
                   (rotate + 270) % 360];
  var existingWalls = [];
  var walls = Map.data.get(x, y).walls;
  for (var i = 0; i < walls.length; i++) {
    existingWalls.push(walls[i].getAttribute('rotate'));
  }
  search: for (var c = 0; c < 4; c++) {
    for (var i = 0; i < existingWalls.length; i++) {
      if (candidate[c]==existingWalls[i]) {
        continue search;
      }
    }
    return candidate[c];
  }
}

/* Drawing on the walls */

/**
 * Transforms the given tile such that it is rotated by the given
 * angle.
 */
function rotateTile (tile, type, x, y, angle) {
  tile.setAttribute('rotate', angle);
  if (angle > 0) {
    var cx = (x + 1.5) * Map.tileWidth; // empty column to the left
    var cy = (y + 1.5) * Map.tileWidth; // empty row at the top
    tile.setAttribute('transform', 'rotate('+angle+','+cx+','+cy+')');
  } else {
    tile.removeAttribute('transform');
  }
}

/**
 * Places a tile of the given type on a free section of the wall
 * around the given square.
 */
function wallPlacement (x, y, type) {
  var now = new Date();
  var walls = Map.data.get(x, y).walls;
  if (Pen.type === type
      && walls  && walls.length > 0
      && Pen.ts && now - Pen.ts <= 2000) {
    // we just placed a door: take the last one and rotate it
    var tile = walls[walls.length - 1];
    var old = tile.getAttribute('transform');
    var angle = parseInt(tile.getAttribute('rotate'));
    var rotate = getUnusedAngle(x, y, (angle + 90) % 360);
    if (rotate !== null) {
      type = tile.type; // use 'concealed' instead of 'door' for example
      Commands.do(
        function(){
          rotateTile(tile, type, x, y, angle);
        },
        function(){
          rotateTile(tile, type, x, y, rotate);
        });
    }
  } else {
    var rotate = getUnusedAngle(x, y, 0);
    if (rotate !== null) {
      var tile = createTile(x, y, type);
      rotateTile(tile, type, x, y, rotate);
      Commands.do(
        function(){
          walls.pop();
          Map.wallsElement.removeChild(tile);
        },
        function(){
          walls.push(tile);
          Map.wallsElement.appendChild(tile);
        });
    }
  }
  Pen.ts = now;
}

/**
 * Draws a wall tile of the given type on the current wall. The
 * current wall only makes sense in Wall Mode. In Wall Mode, one of
 * the two coordinates is +0.5. We determine the angle (0 or 90) and
 * put a tile there.
 */
function wallDraw (x, y, type) {
  var angle = 0;
  if (y % 1 === 0) {
    x = Math.ceil(x);
  } else {
    angle = 90;
    y = Math.ceil(y);
  }
  var i, old;
  var tile = createTile(x, y, type);
  var walls = Map.data.get(x, y).walls;
  rotateTile(tile, type, x, y, angle);
  for (i = 0; i < walls.length; i++) {
    if (parseInt(walls[i].getAttribute('rotate')) == angle) {
      old = walls[i];
      break;
    }
  }
  Commands.do(
    function(){
      Map.wallsElement.removeChild(tile);
      if (old) {
        Map.wallsElement.appendChild(old);
        walls[i] = old;
      } else {
        walls.pop();
      }
    },
    function(){
      if (old) {
        Map.wallsElement.removeChild(old);
        walls[i] = tile;
      } else {
        walls.push(tile);
      }
      Map.wallsElement.appendChild(tile);
    });
}

/**
  * Toggles Wall Mode.
  */
function wallMode (x, y) {
  if (Pen.type === 'wallMode') {
    wallModeOff();
  } else {
    Pen.type = 'wallMode';
    if (Pen.x > 0) {
      Pen.x -= 0.5;
    } else {
      Pen.x += 0.5;
    }
  }
  Pen.update(null);
}

/**
 * Places a tile of the given type in the given square. If in Wall
 * Mode, use the given wall. Otherwise, find a free section around the
 * given square.
 */
function wall (x, y, type) {
  if (Pen.type === 'wallMode') {
    wallDraw(x, y, type);
  } else {
    wallPlacement(x, y, type);
    Pen.type = type;
  }
}

/**
 * Finds a wall tile for the current position of a given angle in wall
 * mode and return its index in the wall array. You're meant to call
 * this multiple times: Once for (x, y) where the angle could be 0° or
 * 90°, once for (x-1, y) where the angle could be 180° and once for
 * (x, y-1) where the angle could be 270°.
 */
function findWall (walls, angle) {
  for (var i = 0; i < walls.length; i++) {
    if (parseInt(walls[i].getAttribute('rotate')) == angle) {
      return i;
    }
  }
  return null;
}

/**
 * Removes a tile from the surrounding walls of the give tile.
 * Returns true if there was a wall.
 */
function removeWall (x, y) {
  var angle = 0;
  if (Pen.type === 'wallMode') {
    if (y % 1 === 0) {
      x = Math.ceil(x);
    } else {
      angle = 90;
      y = Math.ceil(y);
    }
  }
  var walls = Map.data.get(x, y).walls;
  var i;
  if (Pen.type === 'wallMode') {
    i = findWall(walls, angle);
    if (i === null && angle === 0 && x > 0) {
      walls = Map.data.get(x - 1, y).walls;
      i = findWall(walls, 180);
    }
    if (i === null && angle === 90 && y > 0) {
      walls = Map.data.get(x , y - 1).walls;
      i = findWall(y - 1, y, 270);
    }
  } else {
    i = walls.length - 1;
  }
  if (i !== null && i >= 0) {
    var old = walls[i];
    Commands.do(
      function(){
        Map.wallsElement.appendChild(old);
        walls.push(old);
      },
      function(){
        Map.wallsElement.removeChild(old);
        walls.splice(i,1);
      });
    return true;
  }
}

/**
 * Draws a tile on the floor. If the tile it already there, draws
 * floor instead. Stairs are taken care of---they are on a different
 * layer!
 */
function draw (x, y, type) {
  var old = Map.data.get(x, y).floor;
  if (old !== null && old.type === type) {
    floor(x, y);
  } else {
    replaceFloor(x, y, old, createTile(x, y, type));
  }
}

/**
 * Replaces the old tile on the floor with a new tile. The code
 * handles both the old tile and the new tile being null.
 * If both are null, nothing needs to be done.
 */
function replaceFloor(x, y, old, tile) {
  if (old !== null || tile !== null) {
    Commands.do(
      function(){
        if (tile)
          Map.floorElement.removeChild(tile);
        if (old)
          Map.floorElement.appendChild(old);
        Map.data.get(x, y).floor = old;
      },
      function(){
        if (old) {
          Map.floorElement.removeChild(old);
        }
        if (tile)
          Map.floorElement.appendChild(tile);
        Map.data.get(x, y).floor = tile;
      });
  }
}

/**
 * Returns the number of steps required to turn b into variant a. If a
 * is not a variant of b, returns undefined. From stairs to stairs is
 * 0, so this is not truthy! Use isVariantOf if you need that.
 */
function variantOf(a, b) {
  if (a === b)
    return 0;
  var matches = {};
  for (var next = b, i = 1; next !== undefined && Map.variants[next] !== b; next = Map.variants[next], i++) {
    matches[next] = i;
  }
  return matches[a];
}

/**
 * Returns whether a is a variant of b.
 */
function isVariantOf(a, b) {
  if (a === b)
    return true;
  return variantOf(a, b) !== undefined;
}

/**
 * Replaces the last tile placed with a variant thereof.
 */
function variant (x, y) {
  var tile;
  if (Pen.type === 'wallMode') {
    if (y % 1 === 0) {
      x = Math.ceil(x);
    } else {
      y = Math.ceil(y);
    }
  }
  tile = Map.data.get(x, y).floor;
  if (Pen.type === 'wallMode'
      || isVariantOf(Pen.type, 'door')
      || isVariantOf(Pen.type, 'wall')
      || tile !== null && Map.variants[tile.type] === undefined) {
    var walls = Map.data.get(x, y).walls;
    tile = walls[walls.length - 1];
  }
  if (tile) {
    var old = tile.type;
    var type = Map.variants[tile.type];
    if (type) {
      Commands.do(
        function(){
          tile.type = old;
          tile.setAttribute('id', old + '_' + x + '_' + y);
          tile.setAttributeNS(xlinkNs, 'href', '#' + old);
        },
        function(){
          tile.type = type;
          tile.setAttribute('id', type + '_' + x + '_' + y);
          tile.setAttributeNS(xlinkNs, 'href', '#' + type);
        });
    }
  }
}

/**
 * Draws stairs and diagonals on the floor.
 */
function floorRotate (x, y, type) {
  var old = Map.data.get(x, y).floor;
  if (old && isVariantOf(old.type, type) !== null && old.hasAttribute('rotate')) {
    var angle = parseInt(old.getAttribute('rotate'));
    Commands.do(
      function(){
        rotateTile(old, type, x, y, angle);
      },
      function() {
        rotateTile(old, type, x, y, (angle + 90) % 360);
      });
  } else {
    var tile = createTile(x, y, type);
    tile.setAttribute('rotate', 0);
    replaceFloor(x, y, old, tile);
  }
}

/**
 * Draws or erases a floor tile.
 */
function floor (x, y) {
  var old   = Map.data.get(x, y).floor;
  if (!old || old.type !== 'empty') {
    replaceFloor(x, y, old, createTile(x, y, 'empty'));
  } else {
    replaceFloor(x, y, old, null);
  }
}

/**
 * Erase floor tile, if any.
 */
function removeFloor (x, y) {
  var old   = Map.data.get(x, y).floor;
  if (old)
    replaceFloor(x, y, old, null);
}

/* This is where we draw (or erase) floor tiles. The key point to
 * remember is that we might not get a mouse event for every
 * coordinate. That's why we need to store where we want to draw to
 * (our target) and start drawing at our current position (the pen).
 * We do this at least once in order to support clicks without mouse
 * movement. Then we start a loop: as long as the pen hasn't reached
 * the target, we change x or y by 1 and draw another tile. As we're
 * creating closures for Commands, we need to do this in a factory.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Creating_closures_in_loops.3A_A_common_mistake
 */
function drawToCommand (x, y, tile, type) {
  record('('+x+','+y+')f');
  var remove = function(){
    Map.floorElement.removeChild(tile);
    Map.data.get(x, y).floor = null;
  };
  var add = function(){
    Map.data.get(x, y).floor = tile;
    Map.floorElement.appendChild(tile);
  };
  if (type === 'add') {
    Commands.do(remove, add); // add new tile
  } else {
    Commands.do(add, remove); // remove existing tile
  }
}

/**
 * Call drawToCommand based on the position data in the event.
 */
function drawTo (evt) {
  var target = Pen.position(evt);
  // draw up to the current position (at least once if we just started)
  do {
    if (!Map.data.get(Pen.x, Pen.y).floor && Pen.type === 'empty') {
      drawToCommand(Pen.x, Pen.y, createTile(Pen.x, Pen.y, 'empty'), 'add');
    } else if (Map.data.get(Pen.x, Pen.y).floor && Pen.type === 'null') {
      drawToCommand(Pen.x, Pen.y, Map.data.get(Pen.x, Pen.y).floor, 'remove');
    }
  } while (Pen.moveTo(target));
  Pen.update(evt);
}

/**
 * Sets the Pen down, ready for drawing. When setting down the pen
 * (onmousedown, penDown), we look at the current tile. If it's the
 * empty floor tile, we'll want to erase it. If there is no floor tile
 * (null), we'll want to draw an empty floor tile. We store this
 * information in the Pen type and as we keep on drawing (onmousemove,
 * drawTo), we don't change it.
 *
 * As for touch screens: If we are just touching the screen, don't
 * draw a tile. If we keep touching the screen, however, draw a tile.
 */
function penDown (evt) {
  wallModeOff();
  Pen.update(evt);
  if (Map.data.get(Pen.x, Pen.y).floor) {
    Pen.type = 'null';
  } else {
    Pen.type = 'empty';
  }
  // draw a tile unless we just touched the screen
  if (evt.type === 'touchstart') {
    var ts = Date.now();
    var pos = Pen.x + "," + Pen.y;
  } else {
    drawTo(evt);
  }
  // install new handler
  Map.ui.onmousemove = drawTo;
  Map.ui.ontouchmove = drawTo;
  // revert to pen tracking on mouse up *anywhere*
  document.onmouseup = function() {
    Map.ui.onmousemove = Pen.update;
  }
  document.ontouchend = function() {
    // if this was a long touch and we haven't moved, draw a tile anyway
    if (Date.now() > ts + 300 && pos === Pen.x + "," + Pen.y) {
      drawTo(evt);
    }
    Map.ui.ontouchmove = Pen.update;
  }
}

/**
 * Puts the pointer back into a square and ends Wall Mode.
 * Call this whenever you're acting on squares.
 */
function wallModeOff () {
  Pen.x = Math.ceil(Pen.x);
  Pen.y = Math.ceil(Pen.y);
  Pen.update(null);
  Pen.type = null;
}

/**
 * Moves the pointer around. It handles both moving from square to
 * sqare as well as moving from wall to wall (where one of the
 * coordinates is off by 0.5).
 */
function move (dir) {
  switch (dir) {
  case 'left':
    if (Pen.x > 0)
      Pen.x--;
    break;
  case 'right':
    Map.growWithAnimation(Pen.x + 1);
    Pen.x++;
    break;
  case 'up':
    if (Pen.y > 0)
      Pen.y--;
    break;
  case 'down':
    if (Pen.y + 1 >= Map.height) {
      Map.height++;
      moveElements();
    }
    Pen.y++;
    break;
  }
  // Example: when moving down from 1 to 2 and right to 3, we want to
  // switch position on the grid and end up on 4. So we need to adjust
  // the position by (-0.5,-0.5):
  //
  //  x→
  // y  |   |
  // ↓--+---+---
  //    1   |
  //  --+-4-+---
  //    2   3
  //  --+---+---
  //    |   |
  //
  // If we moved first right and then down, we would end up in the same
  // position.
  if (Pen.type === 'wallMode') {
    var now = new Date();
    if (Pen.dir && Pen.ts && now - Pen.ts <= 500) {
      if (Pen.dir=='left' && dir=='down'
          || Pen.dir=='down' && dir=='left') {
        Pen.x += 0.5;
        Pen.y -= 0.5;
      } else if (Pen.dir=='left' && dir=='up'
                 || Pen.dir=='up' && dir=='left') {
        Pen.x += 0.5;
        Pen.y += 0.5;
      } else if (Pen.dir=='right' && dir=='down'
                 || Pen.dir=='down' && dir=='right') {
        Pen.x -= 0.5;
        Pen.y -= 0.5;
      } else if (Pen.dir=='right' && dir=='up'
                 || Pen.dir=='up' && dir=='right') {
        Pen.x -= 0.5;
        Pen.y += 0.5;
      }

    }
  }
  Pen.update(null);
  Pen.dir = dir;
  Pen.ts = now; // must come after Pen.update
}

/**
 * Extract key from KeyboardEvent Basic source from
 * http://javascript.info/tutorial/keyboard-events#processing-the-character-keypress
 */
function getChar(event) {
  if (event.which == null) {
    return String.fromCharCode(event.keyCode) // IE character keys
  } else if (event.which!=0 && event.charCode!=0) {
    return String.fromCharCode(event.which) // the rest character keys
  } else if (event.type == 'keydown') { // special key
    if(event.key && event.key.length !== 1) return event.key; // Firefox
    if(event.keyIdentifier && event.keyIdentifier.substring(0,2) !== 'U+') return event.keyIdentifier; // Chrome
    if(event.keyCode === 8) return 'Backspace'; // Chrome Backspace
  }
  return null; // ignore second key event
}

/**
 * Processes key press events and single character strings (in case
 * the interpreter is feeding us some). Many of the key commands need
 * a 'current' position. We determine it by looking at the Pen. It's
 * position is always tracked (onmousemove, Pen.update).
 */
function keyPressed (evt) {
  // We don't handly any meta keys.
  if (evt.metaKey)
    return;
  
  // Could be a string when running interpreted code.
  var key = evt;
  var isRecorded = true;
  
  // When running the demo, ignore key events from the browser.
  if (!Demo.running && evt instanceof KeyboardEvent) {
    key = getChar(evt);
    if(key === null) return; // ignore one of onkeydown or onkeypress event
  }

  var target = evt.originalTarget || evt.srcElement; // Chrome
  if (target === Map.exportarea) {
    if (key === 'Enter' && evt.ctrlKey) {
      textImport();
    }
    return;
  }

  if (target !== undefined && target.parentNode === Map.labelfield) {
    if (key === 'Enter') {
      saveLabel();
      record(Map.data.get(Pen.x, Pen.y).label.textContent + '"');
    } else if (key === 'Esc') {
      hideLabelField();
    }
    return;
  }

  if (key === 'Backspace') {
    evt.preventDefault();
  }

  switch (key) {

  case '?':
    var help = document.getElementById('help');
    if (help.getAttribute('visibility') === 'hidden') {
      help.setAttribute('visibility', 'visible');
    } else {
      help.setAttribute('visibility', 'hidden');
    }
    break;

  case '.':
    Pen.ts = null;
    break;

  case 'u':
    Commands.undo();
    break;

  case 'r':
    Commands.redo();
    break;

  case 'ArrowDown':
  case 'Down':
  case 'j':
  case 'J':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('down');
    key = '(' + Pen.x + ',' + Pen.y + ')';
    break;

  case 'ArrowUp':
  case 'Up':
  case 'k':
  case 'K':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('up');
    key = '(' + Pen.x + ',' + Pen.y + ')';
    break;

  case 'ArrowLeft':
  case 'Left':
  case 'h':
  case 'H':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('left');
    key = '(' + Pen.x + ',' + Pen.y + ')';
    break;

  case 'ArrowRight':
  case 'Right':
  case 'l':
  case 'L':
  case ' ':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('right');
    key = '(' + Pen.x + ',' + Pen.y + ')';
    break;

  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
  case '0':
    addToLabel(Pen.x, Pen.y, key);
    break;

  case 'x':
  case 'Backspace':
  case 'Del':
    if (Pen.type === 'wallMode') {
      if (!removeWall(Pen.x, Pen.y)) {
        wallModeOff();
        deleteFromLabel(Pen.x, Pen.y)
          || removeFloor(Pen.x, Pen.y, null, null);
      }
    } else {
      deleteFromLabel(Pen.x, Pen.y)
        || removeWall(Pen.x, Pen.y)
        || removeFloor(Pen.x, Pen.y, null, null);
    }
    key = 'x'; // record x
    break;

  case 'f':
    wallModeOff();
    floor(Pen.x, Pen.y);
    break;

  case '\n':
  case 'Enter':
    if (evt.ctrlKey) {
      textImport();
      isRecorded = false; // don't record this one
    } else {
      wallModeOff();
      Pen.x = 0;
      move('down');
      key = '\n'; // record a newline
    }
    break;

  case 'd':
    wall(Pen.x, Pen.y, 'door');
    break;

  case 'w':
    wall(Pen.x, Pen.y, 'wall');
    break;

  case 'm':
    wallMode(Pen.x, Pen.y);
    break;

  case 'p':
    wallModeOff();
    draw(Pen.x, Pen.y, 'pillar');
    break;

  case 't':
    wallModeOff();
    draw(Pen.x, Pen.y, 'trap');
    break;

  case 'b':
    wallModeOff();
    draw(Pen.x, Pen.y, 'statue');
    break;

  case 'c':
    wallModeOff();
    draw(Pen.x, Pen.y, 'chest');
    break;

  case 's':
    wallModeOff();
    floorRotate(Pen.x, Pen.y, 'stair');
    break;

  case 'v':
    variant(Pen.x, Pen.y);
    break;

  case 'n':
    wallModeOff();
    floorRotate(Pen.x, Pen.y, 'diagonal');
    break;

  case 'z':
    if (Map.level < 665) {
      Map.show(Map.level + 1);
    }
    break;

  case 'y':
    if (Map.level > 0) {
      Map.show(Map.level - 1);
    }
    break;

  case 'Z':
    if (Map.hideOthers) {
      Map.showLevelAnimation();
    } else {
      Map.hideOtherLevels();
    }
    Map.hideOthers = !Map.hideOthers;
    break;

  case '"':
  case "'": // for the "abc" link: " is processed by interpretCont
    showLabelField(Pen.x, Pen.y);
    break;

  default:
    console.log('Gridmapper does not know how to handle "'+ key
                + '" (keyIdentifier: '+evt.keyIdentifier+', keyCode: '+ evt.keyCode+')');
    isRecorded = false;
    break;
  }

  if (isRecorded) {
    record(key);
  }
}

/**
 * Interprets a sequence of characters as a script. Most of the job
 * will be handled by keyPressed. The interpreter adds a few extra
 * characters which are only useful non-interactively.
 *
 * '.' will reset the Pen's timestamp, simulating a pause (to prevent
 * rotating the last tile)
 *
 * ';' will cause a pause (using a timeout). This is used for the
 * demo. This is why the real code runs as interpretCont – it has a
 * pointer into the code. 
 * 
 * '(1,2)' will move the pointer to this position.
 *
 * '[0,-1]' will move the pointer by this vector.
 *
 * '"abc"' will insert the label abc (instead of showing an input
 * field). This is why the link in the help area sends a single quote
 * instead of a double quote. The double quote is already taken for
 * strings.
 * 
 * 'z' has an alternate implementation: when loading a map, going down
 * should not animate anything, unless we're looking at the demo.
 *
 * '-' moves point to the left (a shorthand for '[-1,0]') if we have not
 * joined a map and the next character is neither 'v' (a variation)
 * nor a newline.
 *
 * 'f' places a floor tile and moves to the right unless you're 
 *
 * '\01' or '\02' causes a map reset and is followed by a new map
 * until we get to the '\03' character (Ctrl-A is Start of Heading,
 * Ctrl-B is Start Of Text, Ctrl-C is End Of Text), because while the
 * map is being read, '-' and 'f' have the same meaning as while
 * loading a map...
 * 
 * '\04' cases the client to leave the map (Ctrl-D is End Of Transmission).
 */
function interpret (code) {
  if (!Map.joined) {
    interpretCont(code, 0);
  }
}

/**
 * Continues the interpretation where we left oft. The variables are
 * not initialized so that we can simply pick up where we left off.
 * This is because we want to interrupt the computation using
 * timeouts.
 */
function interpretCont (code, i) {
  for (; i < code.length; i++) {
    var advance = null;
    switch(code[i]) { // needs charAt?
    case ';':
      setTimeout(function() {
        interpretCont(code, i + 1);
      }, 500);
      return; // end!
    case '(':
      var match = code.substr(i).match(/^\((\d+(?:\.\d+)?),(\d+(?:\.\d+)?)(?:,(\d+))?\)/);
      if (match) {
        // no longer ints!
        var x = Number(match[1]);
        var y = Number(match[2]);
        var z = Number(match[3]);
        if (Demo.running) {
          if (Pen.moveTo({x: x, y: y})) {
            Pen.update(null);
            setTimeout(function() {
              interpretCont(code, i);
            }, 100);
            return; // end!
          }
        } else {
          Pen.x = x;
          Pen.y = y;
          if (z >= 0)
            Map.jump(z);
          if (Map.joined)
            Pen.update(null);
        }
        i += match[0].length - 1; // will get incremented above
      }
      break;
    case '[':
      var match = code.substr(i).match(/^\[(-?\d+),(-?\d+)\]/);
      if (match) {
        Pen.x += Number(match[1]);
        Pen.y += Number(match[2]);
        i += match[0].length - 1; // will get incremented above
      }
      break;
    case '"':
      var match = code.substr(i).match(/^"(.*?)"/);
      if (match) {
        setLabel(Pen.x, Pen.y, match[1], false); // replace label
        i += match[0].length - 1; // will get incremented above
      }
      break;
    case '-':
      advance = 'left';
      break;
    case 'z':
      // When loading from an URL, we need to reposition the Pen, and
      // we want to be quick. When running the Demo, we do not.
      if (Demo.running || Map.joined) {
        Map.show(Map.level + 1);
      } else {
        Pen.x = 0;
        Pen.y = 0;
        Pen.type = null;
        Map.jump(Map.level + 1);
      }
      break;
    case '\01': // Ctrl-A
    case '\02': // Ctrl-B
      Map.reset();
      Map.joined = false; // start loading a map
      break;
    case '\03': // Ctrl-C
      if (Map.websocket !== null && Map.websocket.readyState === WebSocket.OPEN)
          Map.joined = true; // end of loading a map
      break;
    case '\04': // Ctrl-D
      leave();
      break;
    case 'f':
        advance = 'right';
      // fall through to default
    default:
      keyPressed(code[i]);
    }
    // advance unless we're going to move elsewhere or switch a
    // variant (peek ahead); also don't advance when we joined a
    // hosted map
    if (!Map.joined && advance && code[i+1] !== 'v'
        && code[i+1] !== '\n' && code[i] !== '(' && code[i] !== '[')
      move(advance);
  }
}

/**
 * Recreates the models based on existing SVG elements (if loading a
 * saved file) and the URL (if loading a page). When loading a file,
 * We go through the elements and add the appropriate data to the
 * various data models. When loading from a URL, we look at the
 * keyword parameter and interpret it as a key sequence one might
 * conceivably type. The only difference is the . character which is
 * used to simulate a little pause (to prevent doors from rotating).
 */
function recreateModel () {
  var re = /^([-a-z]+)_(\d+)_(\d+)$/;
  var z = 0;
  for (var map; map = document.getElementById('level'+z); z++) {
    var data = new Tiles();
    recreateModelFor(re, data, document.getElementById('floor'+z));
    recreateModelFor(re, data, document.getElementById('labels'+z));
    recreateModelForDoors(re, data, document.getElementById('walls'+z));
    Map.levels[z] = data;
  }
  if (z === 0) {
    createLevel(0);
  }
  // start at level 0
  Map.setLevel(0);
  // parse URL
  var str = decodeURIComponent(window.location.search);
  if (str.substr(0, 6) === '?load=') {
    loadMap(wikiUrl + '/' + str.substr(6));
  } else if (str.substr(0, 6) === '?join=') {
    Map.exportarea.value = decodeURIComponent(str.substr(6));
    join();
  } else if (str.charAt(0) === '?') {
    interpret(str.substring(1));
  }
  // at the end, move to the top of the dungeon and show it
  Map.jump(0);
  Map.showLevelAnimation();
  moveElements(); // animate grows in the end
}

/**
 * Recreates one particular model based on a matching SVG element.
 * This looks only at id attributes.
 */
function recreateModelFor (re, data, element) {
  for (var child = element.firstElementChild; child; child = child.nextElementSibling) {
    var result = child.getAttribute('id').match(re);
    if (result) {
      child.type = result[1]; // to enable code generation
      var x = result[2];
      var y = result[3];
      if (result[1] === 'label') {
        data.get(x, y).label = child;
      } else {
        data.get(x, y).floor = child;
      }
    }
  }
}

/**
 * Recreates one particular wall model on a matching SVG element.
 * This looks only at id attributes.
 */
function recreateModelForDoors (re, data, element) {
  for (var child = element.firstElementChild; child; child = child.nextElementSibling) {
    var result = child.getAttribute('id').match(re);
    if (result) {
      child.type = result[1]; // to enable code generation
      var x = result[2];
      var y = result[3];
      data.get(x, y).walls.push(child);
    }
  }
}

/**
 * Creates the SVG elements for a level. This must match the
 * expectations in recreateModel.
 */
function createLevel (z) {
  var level = document.createElementNS(svgNs, 'g');
  level.setAttribute('id', 'level' + z);
  level.setAttributeNS(inkscapeNs, 'groupmode', 'layer');
  level.setAttributeNS(inkscapeNs, 'label', 'Level ' + (z + 1));
  var floor = document.createElementNS(svgNs, 'g');
  floor.setAttribute('id', 'floor' + z);
  var labels = document.createElementNS(svgNs, 'g');
  labels.setAttribute('id', 'labels' + z);
  var walls = document.createElementNS(svgNs, 'g');
  walls.setAttribute('id', 'walls' + z);
  level.appendChild(floor);
  level.appendChild(labels);
  level.appendChild(walls);
  Map.levelsElement.insertBefore(level, Map.levelsElement.firstChild);
  Map.levels[z] = new Tiles();
}

/**
 * Initialize the user interface.
 */
function initialize () {
  scaleTiles();
  Map.initialize(); // don't reset the Map so we can load from a file
  Pen.update(null); // show it
  if (window.location.hostname === 'localhost') {
    // testing
    wikiUrl = 'http://localhost/cgi-bin/wiki';
    serverUrl = 'http://localhost:3000';
    wsUrl = 'ws://localhost:3000';
  }
  document.getElementById('join').setAttribute('href', serverUrl);
  recreateModel(); // create model from SVG or URL
}

onload = initialize;
]]></script>
  <defs>
    <rect id="cursor" width="10" height="10" fill="forestgreen" opacity="0.2"/>
    <rect id="empty" width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
    <rect id="void" width="10" height="10" fill="none" stroke="black" stroke-width="1"/>
    <g id="water" width="20">
      <rect width="20" height="20" fill="white" stroke="black" stroke-width="2"/>
      <path id="waves" fill="none" stroke="black" stroke-width="1" d="M3,5 v-1 A1,1 0 0,1 5,4 A1,1 0 1,0 7,4 A1,1 0 0,1 9,4 A1,1 0 1,0 11,4 A1,1 0 0,1 13,4 A1,1 0 1,0 15,4 A1,1 0 0,1 17,4 v1" />
      <use xlink:href="#waves" transform="translate(0,6)"/> 
      <use xlink:href="#waves" transform="translate(0,12)"/> 
    </g>
    <g id="wall" width="10">
      <line x1="0" y1="0" x2="0" y2="10" stroke="black" stroke-width="3" stroke-linecap="round"/>
    </g>
    <g id="curtain" width="20">
      <path fill="none" stroke="black" stroke-width="1" d="M5,3 h-1 A1,1 0 0,0 4,5 A1,1 0 0,1 4,7 A1,1 0 0,0 4,9 A1,1 0 0,1 4,11 A1,1 0 0,0 4,13 A1,1 0 0,1 4,15 A1,1 0 0,0 4,17 h1" />
    </g>
    <g id="portcullis" width="10">
      <circle cx="2" cy="2" r="1" fill="black"/>
      <circle cx="2" cy="5" r="1" fill="black"/>
      <circle cx="2" cy="8" r="1" fill="black"/>
    </g>
    <g id="door" width="10">
      <rect x="-1.5" y="2" width="3" height="6" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="secret" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -2,1 -3,5 0,5 S 2,9 -2,7" />
    </g>
    <g id="concealed" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -3,1 -3,9 2,7" />
    </g>
    <g id="gate" width="10">
      <rect x="-2" y="4" width="4" height="12" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="pillar" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="2" fill="black"/>
    </g>
    <g id="altar" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="3" width="6" height="4" fill="none" stroke="black" stroke-width="0.5"/>
      <circle cx="3.5" cy="5" r="0.5"/>
      <circle cx="6.5" cy="5" r="0.5"/>
    </g>
    <g id="dais" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="none" stroke="black" stroke-width="0.5"/>
      <rect x="3" y="3" width="4" height="4" fill="none" stroke="black" stroke-width="0.5"/>
      <rect x="4" y="4" width="2" height="2" fill="none" stroke="black" stroke-width="0.5"/>
    </g>
    <g id="dais-round" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3" fill="none" stroke="black" stroke-width="0.5"/>
      <circle cx="5" cy="5" r="2" fill="none" stroke="black" stroke-width="0.5"/>
      <circle cx="5" cy="5" r="1" fill="none" stroke="black" stroke-width="0.5"/>
    </g>
    <g id="statue" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3.5" fill="none" stroke="black" stroke-width="0.5"/>
      <path fill="black" d="M 2,4 H 8 L 3,7.5 5,2 7,7.5 Z"/>
    </g>
    <g id="well" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="2.5" fill="black"/>
      <circle cx="5" cy="5" r="1.5" fill="black" stroke="white" stroke-width="1"/>
    </g>
    <g id="fountain" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="2.5" fill="none" stroke="black" stroke-width="0.5"/>
      <circle cx="5" cy="4" r="1.5" fill="none" stroke="black" stroke-width="0.5"/>
    </g>
    <g id="trap" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="white" stroke="black" stroke-width="1"/>
      <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="pit" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="white" stroke="black" stroke-width="1"/>
      <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-width="0.5"/>
      <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-width="0.5"/>
      <rect x="3.2" y="3.2" width="3.6" height="3.6" fill="black"/>
    </g>
    <g id="trap-door-ceiling" width="10" class="labels">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3.5" fill="none" stroke="black" stroke-width="0.5"/>
      <text x="8.3" y="12" transform="scale(0.6,0.6)">C</text>
    </g>
    <g id="trap-door-floor" width="10" class="labels">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3.5" fill="none" stroke="black" stroke-width="0.5"/>
      <text x="8.3" y="12" transform="scale(0.6,0.6)">F</text>
    </g>
    <g id="trap-door-secret" width="10" class="labels">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3.5" fill="none" stroke="black" stroke-width="0.5"/>
      <text x="8.3" y="12" transform="scale(0.6,0.6)">S</text>
    </g>
    <g id="chest" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="3" width="6" height="4" fill="none" stroke="black" stroke-width="0.5"/>
      <line x1="3.5" y1="2" x2="3.5" y2="8" stroke="black" stroke-width="0.5"/>
      <line x1="6.5" y1="2" x2="6.5" y2="8" stroke="black" stroke-width="0.5"/>
    </g>
    <g id="bed" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="3" width="6" height="4" fill="none" stroke="black" stroke-width="0.5"/>
      <line x1="4" y1="3" x2="4" y2="7" stroke="black" stroke-width="0.5"/>
    </g>
    <g id="table" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="3" width="6" height="4" fill="none" stroke="black" stroke-width="0.5"/>
      <circle cx="3.5" cy="4" r="0.5"/>
      <circle cx="3.5" cy="6" r="0.5"/>
      <circle cx="6.5" cy="4" r="0.5"/>
      <circle cx="6.5" cy="6" r="0.5"/>
    </g>
    <g id="diagonal" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <path fill="black" d="M0,10 V0 H10 Z"/>
    </g>
    <g id="arc" width="10">
      <path fill="white" d="M0,10 A10,10 0 0,1 10,0 V10 Z" stroke="black" stroke-width="1"/>
    </g>
    <g id="arc2" width="10">
      <path fill="white" d="M-10,10 A20,20 0 0,1 10,-10 V10 Z" stroke="black" stroke-width="1"/>
      <line x1="-7.3" y1="0" x2="10" y2="0" stroke="black" stroke-width="1"/>
      <line x1="0" y1="-7.3" x2="0" y2="10" stroke="black" stroke-width="1"/>
    </g>
    <g id="arc3" width="10">
      <path fill="white" d="M-20,10 A30,30 0 0,1 10,-20 V10 Z" stroke="black" stroke-width="1"/>
      <line x1="-12.4" y1="-10" x2="10" y2="-10" stroke="black" stroke-width="1"/>
      <line x1="-18.3" y1="0" x2="10" y2="0" stroke="black" stroke-width="1"/>
      <line x1="-10" y1="-12.4" x2="-10" y2="10" stroke="black" stroke-width="1"/>
      <line x1="0" y1="-18.3" x2="0" y2="10" stroke="black" stroke-width="1"/>
    </g>
    <g id="stair" width="10">
      <rect width="10" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="0" y1="3" x2="10" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="1" y1="6" x2="9" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="9" x2="8" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="12" x2="7" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="15" x2="6" y2="15" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair-small" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <line x1="1" y1="2" x2="9" y2="2" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="4" x2="8" y2="4" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="6" x2="7" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="8" x2="6" y2="8" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair-big" width="10">
      <rect width="20" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="1" y1="3" x2="19" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="6" x2="18" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="9" x2="17" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="12" x2="16" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="5" y1="15" x2="15" y2="15" stroke="black" stroke-width="0.8"/>
      <line x1="6" y1="18" x2="14" y2="18" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair-big-spiral" width="50">
      <rect width="100" height="100" fill="white" stroke="black" stroke-width="5"/>
      <circle cx="50" cy="50" r="40" fill="none" stroke="black" stroke-width="5"/>
      <line x1="0" y1="50" x2="99" y2="50" stroke="black" stroke-width="5"/>
      <line x1="50" y1="0" x2="50" y2="100" stroke="black" stroke-width="5"/>
      <line x1="15" y1="30" x2="85" y2="70" stroke="black" stroke-width="5"/>
      <line x1="15" y1="70" x2="85" y2="30" stroke="black" stroke-width="5"/>
      <line x1="30" y1="15" x2="70" y2="85" stroke="black" stroke-width="5"/>
      <line x1="30" y1="85" x2="70" y2="15" stroke="black" stroke-width="5"/>
      <circle cx="50" cy="50" r="10" fill="white" stroke="black" stroke-width="5"/>
    </g>
    <g id="stair-spiral" width="100">
      <rect width="100" height="100" fill="white" stroke="black" stroke-width="10"/>
      <circle cx="50" cy="50" r="40" fill="none" stroke="black" stroke-width="7"/>
      <line x1="10" y1="50" x2="90" y2="50" stroke="black" stroke-width="7"/>
      <line x1="50" y1="10" x2="50" y2="90" stroke="black" stroke-width="7"/>
      <line x1="22" y1="22" x2="78" y2="78" stroke="black" stroke-width="7"/>
      <line x1="22" y1="78" x2="78" y2="22" stroke="black" stroke-width="7"/>
      <circle cx="50" cy="50" r="10" fill="white" stroke="black" stroke-width="7"/>
    </g>
  </defs>
  <g id="background" inkscape:groupmode="layer" inkscape:label="Background">
    <rect x="20" y="20" width="0" height="0" fill="lightgrey" stroke="black" stroke-width="1"/>
  </g>
  <g id="levels" inkscape:groupmode="layer" inkscape:label="Levels"/>
  <use id="pointer" xlink:href="#cursor"/>
  <rect id="ui" opacity="0"/>

  <style><![CDATA[
  svg { overflow: visible }
  text { font: 14px 'Courier New', Courier, monospace }
  textarea { font: 10px 'Courier New', Courier, monospace }
  p { margin: 0 0 10px 0; padding: 0; }
  text { font: 14px 'Courier New', Courier, monospace; }
  .line {  }
  .line svg { display: inline; vertical-align: middle }
  .labels text, #levels text, #label { text-anchor: middle; font: 10px 'Arial Narrow', sans-serif; font-weight: bold; }
  a { color: black; text-decoration: none; }
  .blue { fill: blue; }
  .key { color: forestgreen; fill: forestgreen; font-weight: bold; }
  .invisible { display: none; }
  #ui { -webkit-tap-highlight-color: rgba(0,0,0,0); }
  .menu a rect:hover { opacity: 0.2; fill: forestgreen }
  ]]></style>

  <g id="help">
    <rect x="10" y="80" width="440" height="600" fill="ivory" stroke="black" stroke-width="1"/>
    <text>
      <tspan x="30" y="102">Use the mouse to draw and erase floor tiles.</tspan>
      <tspan x="30" dy="17">Use the following keys to place or rotate</tspan>
      <tspan x="30" dy="17">tiles. <a xlink:href="javascript:interpret('v')">Use <tspan class="key">v</tspan> to use variants</a>.</tspan>
    </text>

    <svg x="30" y="150">
      <a href="javascript:interpret('f')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">f</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('f')" title="floor">
	<use x="50" xlink:href="#empty"/>
      </a>
      <a xlink:href="javascript:interpret('fv')" title="void">
	<rect x="80" width="20" height="20" fill="ivory"/>
	<use x="80" xlink:href="#void"/>
      </a>
      <a xlink:href="javascript:interpret('fvv')" title="water">
	<use x="110" xlink:href="#water"/>
      </a>
    </svg>

    <svg x="30" y="180">
      <a href="javascript:interpret('t')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">t</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('t')" title="covered pit">
	<use x="50" xlink:href="#empty"/>
	<use x="50" xlink:href="#trap"/>
      </a>
      <a xlink:href="javascript:interpret('tv')" title="open pit">
	<use x="80" xlink:href="#empty"/>
	<use x="80" xlink:href="#pit"/>
      </a>
      <a xlink:href="javascript:interpret('tvv')" title="trap door in the ceiling">
	<use x="110" xlink:href="#empty"/>
	<use x="110" xlink:href="#trap-door-ceiling"/>
      </a>
      <a xlink:href="javascript:interpret('tvvv')" title="trap door in the floor">
	<use x="140" xlink:href="#empty"/>
	<use x="140" xlink:href="#trap-door-floor"/>
      </a>
      <a xlink:href="javascript:interpret('tvvvv')" title="secret trap door">
	<use x="170" xlink:href="#empty"/>
	<use x="170" xlink:href="#trap-door-secret"/>
      </a>
    </svg>

    <svg x="30" y="210">
      <a href="javascript:interpret('b')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">b</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('b')" title="statue">
	<use x="50" xlink:href="#empty"/>
	<use x="50" xlink:href="#statue"/>
      </a>
      <a xlink:href="javascript:interpret('bv')" title="well">
	<use x="80" xlink:href="#empty"/>
	<use x="80" xlink:href="#well"/>
      </a>
      <a xlink:href="javascript:interpret('bvv')" title="fountain">
	<use x="110" xlink:href="#empty"/>
	<use x="110" xlink:href="#fountain"/>
      </a>
    </svg>

    <svg x="30" y="240">
      <a href="javascript:interpret('d')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">d</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('d')" title="door">
	<use x="50" xlink:href="#empty"/>
	<use x="50" xlink:href="#door"/>
      </a>
      <a xlink:href="javascript:interpret('dv')" title="secret door">
	<use x="80" xlink:href="#empty"/>
	<use x="80" xlink:href="#secret"/>
      </a>
      <a xlink:href="javascript:interpret('dvv')" title="concealed door">
	<use x="110" xlink:href="#empty"/>
	<use x="110" xlink:href="#concealed"/>
      </a>
      <a xlink:href="javascript:interpret('dvvv')" title="double door, gate">
	<use x="140" y="-20" xlink:href="#empty"/>
	<use x="140" y="" xlink:href="#empty"/>
	<use x="140" y="-20" xlink:href="#gate"/>
      </a>
    </svg>

    <svg x="30" y="270">
      <a href="javascript:interpret('s')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">s</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('s')" title="stairs">
	<use x="50" xlink:href="#stair"/>
      </a>
      <a xlink:href="javascript:interpret('sv')" title="small stairs">
	<use x="80" xlink:href="#stair-small"/>
      </a>
      <a xlink:href="javascript:interpret('svv')" title="spiral stairs">
	<use x="80" y="31" xlink:href="#stair-spiral"/>
      </a>
      <a xlink:href="javascript:interpret('svvv')" title="big spiral stairs">
	<use x="110" xlink:href="#stair-big-spiral"/>
      </a>
      <a xlink:href="javascript:interpret('svvvv')" title="bit stairs">
	<use x="160" xlink:href="#stair-big"/>
      </a>
    </svg>

    <svg x="30" y="320">
      <a href="javascript:interpret('n')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">n</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('n')" title="diagonal">
	<use x="50" y="10" xlink:href="#diagonal"/>
      </a>
      <a xlink:href="javascript:interpret('nv')" title="arc">
	<use x="60" y="40" xlink:href="#arc"/>
      </a>
      <a xlink:href="javascript:interpret('nvv')" title="big arc">
	<use x="110" y="41" xlink:href="#arc2"/>
      </a>
      <a xlink:href="javascript:interpret('nvvv')" title="huge arc">
	<use x="180" y="41" xlink:href="#arc3"/>
      </a>
    </svg>

    <svg x="250" y="150">
      <a href="javascript:interpret('w')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">w</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('w')" title="wall">
	<use x="50" xlink:href="#empty"/>
	<use x="50" xlink:href="#wall"/>
      </a>
      <a xlink:href="javascript:interpret('wv')" title="curtain">
	<use x="80" xlink:href="#empty"/>
	<use x="80" xlink:href="#curtain"/>
      </a>
      <a xlink:href="javascript:interpret('wvv')" title="portcullis">
	<use x="110" xlink:href="#empty"/>
	<use x="110" xlink:href="#portcullis"/>
      </a>
    </svg>

    <svg x="250" y="180">
      <a href="javascript:interpret('p')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">p</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('p')" title="pillar">
	<use x="50" xlink:href="#empty"/>
	<use x="50" xlink:href="#pillar"/>
      </a>
      <a xlink:href="javascript:interpret('pv')" title="altar">
	<use x="80" xlink:href="#empty"/>
	<use x="80" xlink:href="#altar"/>
      </a>
      <a xlink:href="javascript:interpret('pvv')" title="dais">
	<use x="110" xlink:href="#empty"/>
	<use x="110" xlink:href="#dais"/>
      </a>
      <a xlink:href="javascript:interpret('pvvv')" title="round dais">
	<use x="140" xlink:href="#empty"/>
	<use x="140" xlink:href="#dais-round"/>
      </a>
    </svg>

    <svg x="250" y="210">
      <a href="javascript:interpret('c')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">c</tspan> :</text>
      </a>
      <a xlink:href="javascript:interpret('c')" title="chest">
	<use x="50" xlink:href="#empty"/>
	<use x="50" xlink:href="#chest"/>
      </a>
      <a xlink:href="javascript:interpret('cv')" title="bed">
	<use x="80" xlink:href="#empty"/>
	<use x="80" xlink:href="#bed"/>
      </a>
      <a xlink:href="javascript:interpret('cvv')" title="table">
	<use x="110" xlink:href="#empty"/>
	<use x="110" xlink:href="#table"/>
      </a>
    </svg>

    <svg x="250" y="240">
      <a href="javascript:interpret('&apos;')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">"abc"</tspan> :</text>
	<use x="50" xlink:href="#empty"/>
	<g class="labels" title="labels">
	  <text x="60" y="13.5">abc</text>
	</g>
      </a>
    </svg>

    <svg x="250" y="270">
      <text x="30" y="14" text-anchor="end"><tspan class="key">0-9</tspan><tspan> :</tspan></text>
      <use x="50" xlink:href="#empty"/>
      <g class="labels" title="labels">
	<text x="60" y="13.5">123</text>
      </g>
    </svg>

    <svg x="250" y="300">
      <a xlink:href="javascript:interpret('m')">
	<text x="30" y="14" text-anchor="end"><tspan class="key">m</tspan><tspan> :</tspan></text>
      </a>
      <a xlink:href="javascript:interpret('m')" title="Wall Mode">
	<use x="50" xlink:href="#empty"/>
	<use x="40" xlink:href="#cursor"/>
	<text x="90" y="14">Wall Mode</text>
      </a>
    </svg>

    <svg x="250" y="330">
      <text>
	<tspan x="0" y="14">Use arrow keys</tspan>
	<tspan x="0" dy="20">or vi keys</tspan>
	<tspan x="0" dy="20">to move around</tspan>
      </text>
      <text x="150" y="14">
	<a xlink:href="javascript:interpret('k')" title="up">
	  <tspan class="key">k</tspan>
	</a>
      </text>
      <text x="130" y="34">
	<a xlink:href="javascript:interpret('h')" title="left">
	  <tspan class="key">h</tspan>
	</a>
	╋
	<a xlink:href="javascript:interpret('l')" title="right">
	  <tspan class="key">l</tspan>
	</a>
      </text>
      <text x="150" y="54">
	<a xlink:href="javascript:interpret('j')" title="down">
	  <tspan class="key">j</tspan>
	</a>
      </text>
    </svg>

    <text>
      <tspan x="30" y="410">
	<a xlink:href="javascript:keyPressed('u')"><tspan class="key">u</tspan> : undo</a>  
	<a xlink:href="javascript:keyPressed('r')"><tspan class="key">r</tspan> : redo</a>  
	<a xlink:href="javascript:keyPressed('x')">
  	  <tspan class="key">x</tspan>, <tspan class="key">Delete</tspan> : delete
	</a>
      </tspan>

      <tspan x="30" dy="25">
	<a xlink:href="javascript:keyPressed('y')"><tspan class="key">y</tspan> : up</a>  
	<a xlink:href="javascript:keyPressed('z')"><tspan class="key">z</tspan> : down</a>  
	<a xlink:href="javascript:keyPressed('Z')">
  	  <tspan class="key">Z</tspan> : hide other levels
	</a>
      </tspan>

      <tspan x="30" dy="25">
	<a xlink:href="javascript:keyPressed(' ')"><tspan class="key">Space</tspan> : move right</a>  
	<a xlink:href="javascript:keyPressed('Enter')"><tspan class="key">Enter</tspan> : new line</a>
      </tspan>

      <tspan x="30" dy="25">
	<tspan class="key">Arrows</tspan> : move  
	<tspan class="key">Shift Arrows</tspan> : toggle floor
      </tspan>

      <tspan x="30" dy="25">
	<a class="blue" xlink:href="javascript:textExport()">Text Export</a>  
	<a xlink:href="javascript:textImport()"><tspan class="blue">Text Import</tspan> or
	<tspan class="key">Ctrl Enter</tspan></a>
      </tspan>
    </text>

    <foreignObject id="label" x="30" y="515" width="390" height="50">
      <textarea id="exportarea" xmlns="http://www.w3.org/1999/xhtml"
		style="position: fixed; width: 100%; height: 100%; margin: 0; padding: 0"/>
    </foreignObject>
    
    <text>
      <tspan x="30" y="590">
	<a class="blue" xlink:href="https://github.com/kensanata/gridmapper#how-to-save">How to Save</a>  
	<tspan id="download">
	  <a class="blue" xlink:href="javascript:download()">Prepare Download</a>
	</tspan>
	<tspan id="format" display="none">
	  Download
	  <a id="download_svg" class="blue" download="gridmapper.svg">SVG</a>
	  <a id="download_png" class="blue" target="_blank" download="gridmapper.png">PNG</a>
	</tspan>  
	<a id="export" class="blue" xlink:href="javascript:prepareLink()">Prepare Link</a>
      </tspan>

      <tspan x="30" dy="20">
	<a id="save" class="blue" title="Save the map to the wiki" xlink:href="javascript:save()">Save</a>  
	<a id="load" class="blue" title="Load a map from the wiki" xlink:href="javascript:load()">Load</a>  
	<a id="host" class="blue" title="Host a map for your friends" xlink:href="javascript:host()">Host</a>  
	<a id="join" class="blue" title="Join a map being hosted" xlink:href="javascript:join()">Join</a>
	
      </tspan>
      <tspan x="30" dy="20">
	<a class="blue" xlink:href="https://github.com/kensanata/gridmapper">Source</a>  
	<a id="demo" class="blue" xlink:href="javascript:Demo.start()">Demo</a>
      </tspan>
    </text>
      
    <text id="level" x="460" y="110" style="font:30px 'Arial Narrow', sans-serif; font-weight: bold;">1</text>
    <text x="460" y="140" transform="rotate(90,460,140)">
      <a xlink:href="https://alexschroeder.ch/wiki/Gridmapper">
	<tspan style="font-weight: bold;">Gridmapper</tspan>
      </a>
      <tspan>by</tspan>
      <a xlink:href="https://alexschroeder.ch/">
	<tspan style="font-weight: bold;">Alex Schroeder</tspan>
      </a>
    </text>
  </g>

  <foreignObject id="label" x="10" y="10" width="40em" height="20" opacity="0">
    <input xmlns="http://www.w3.org/1999/xhtml" type="text" width="30"/>
  </foreignObject>
  <text id="messages" visibility="hidden">
    <tspan class="step1" x="0" y="0">Hello! This is the demo!</tspan>
    <tspan class="step1" x="0" dy="20">We're going to show you how to use this thing.</tspan>
    <code class="step1">(10,10)</code>

    <tspan class="step2" x="0" y="0">You can move around the map using your mouse.</tspan>
    <tspan class="step2" x="0" dy="20">Or you can use the
    <tspan class="key">Arrow keys</tspan> to move around.</tspan>
    <code class="step2">(20,10)(20,20)(10,20)(10,10)</code>

    <tspan class="step3" x="0" y="0">You can draw the floor using your mouse.</tspan>
    <tspan class="step3" x="0" dy="20">Or you can use
    <tspan class="key">Shift</tspan> and the
    <tspan class="key">Arrow keys</tspan>.</tspan>
    <code class="step3">(13,11)ffff(13,12)ffff(13,13)ffff(13,14)ffff(13,15)ffff</code>

    <tspan class="step4" x="0" y="0">In general I recomend using the
    <tspan class="key">Arrow keys</tspan> to move.</tspan>
    <tspan class="step4" x="0" dy="20">Use <tspan class="key">f</tspan>
    to draw or erase the floor.</tspan>
    <code class="step4">(14,16)ff(14,17)ff(11,18)ffffff(11,19)ffffff(11,20)ffffff;ffff-;f--;f--;f--;f-</code>

    <tspan class="step5" x="0" y="0">Things like traps, statues and pillars are easy.</tspan>
    <tspan class="step5" x="0" dy="20">Just use the appropriate key:
    <tspan class="key">t</tspan>,
    <tspan class="key">b</tspan>,
    <tspan class="key">p</tspan>.</tspan>
    <code class="step5">(12,19)t;(11,19)b;(11,18)p p p;(11,20)p p p</code>

    <tspan class="step6" x="0" y="0">Doors are trickier. Use
    <tspan class="key">d</tspan> to rotate the door.</tspan>
    <tspan class="step6" x="0" dy="20">Watch: left, top, right, bottom, and back to left.</tspan>
    <code class="step6">(17,12);d;d;d;d;d</code>

    <tspan class="step7" x="0" y="0">Secret and concealed doors are variants of doors.</tspan>
    <tspan class="step7" x="0" dy="20">Use
    <tspan class="key">v</tspan> to switch between variants.</tspan>
    <code class="step7">(17,14)dff(18,15)fff(19,16)ff;d;v;v;fff(21,17)fff(23,17);d;d;d;v;(21,18)fff</code>

    <tspan class="step8" x="0" y="0">Use <tspan class="key">s</tspan>
    to set stairs and rotate them into place.</tspan>
    <tspan class="step8" x="0" dy="20">Use <tspan class="key">v</tspan>
    to use a variant.</tspan>
    <code class="step8">(11,12)s;s;s;s;(17,12)ffs;s;s;s;v </code>

    <tspan class="step9" x="0" y="0">You can draw on multiple layers.</tspan>
    <tspan class="step9" x="0" dy="20">Use
    <tspan class="key">z</tspan> and <tspan class="key">y</tspan>
    to move up and down.</tspan>
    <code class="step9">z(21,11)fff(20,12)ffff(21,13)fff;y</code>

    <tspan class="step10" x="0" y="0">Place a door and rotate it into place.</tspan>
    <tspan class="step10" x="0" dy="20">Use <tspan class="key">v</tspan> to select the gate variant.</tspan>
    <code class="step10">(15,16);d;d;v;v;v</code>

    <tspan class="step11" x="0" y="0">Use <tspan class="key">n</tspan>
    to place and rotate diagonals.</tspan>
    <code class="step11">(17,15);n;n;n;n(18,14);n;n</code>

    <tspan class="step12" x="0" y="0">You can draw walls using
    <tspan class="key">w</tspan>.</tspan>
    <tspan class="step12" x="0" dy="20">Thus, walls work just like doors.</tspan>
    <code class="step12">(16,18);dv(16,19);w(16,20);w</code>

    <tspan class="step13" x="0" y="0">This gets tedious very fast.</tspan>
    <tspan class="step13" x="0" dy="20">Use
    <tspan class="key">m</tspan> to enter
    <tspan style="font-weight: bold">Wall Mode</tspan>.</tspan>
    <tspan class="step13" x="0" dy="20">Note the shift by half a square!</tspan>
    <code class="step13">z(21,11);m</code>

    <tspan class="step14" x="0" y="0" style="font-weight: bold">Wall Mode</tspan>
    <tspan class="step14">keeps the cursor on the walls.</tspan>
    <tspan class="step14" x="0" dy="20">Doors and walls no longer rotate.</tspan>
    <code class="step14"> w; w;(21.5,13)w; w</code>

    <tspan class="step15" x="0" y="0">Move from wall to wall and use
    <tspan class="key">d</tspan>,
    <tspan class="key">v</tspan> or
    <tspan class="key">w</tspan>.</tspan>
    <tspan class="step15" x="0" dy="20">Use
    <tspan class="key">m</tspan> to leave Wall Mode.</tspan>
    <code class="step15">(21,11.5)d; d; d;(21,12.5)d; d; d;(23.5,12)dvm</code>

    <tspan class="step16" x="0" y="0">Use the number keys
    <tspan class="key">0-9</tspan> to add labels.</tspan>
    <tspan class="step16" x="0" dy="20">Use
    <tspan class="key">Delete</tspan> to delete labels.</tspan>
    <code class="step16">(20,12)6y(15,12)1(14,19)2(19,16)4(22,17)5</code>

    <tspan class="step17" x="0" y="0">Well, that's it. The rest is up to you.</tspan>
    <tspan class="step17" x="0" dy="20">What lies beyond the secret doors to the east?</tspan>

  </text>
</svg>
