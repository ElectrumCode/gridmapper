<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <desc>Gridmapper, a simple tool to create dungeon maps</desc>

  <script type="application/javascript"><![CDATA[

/* The original author (Alex Schroeder) has dedicated Gridmapper to
 * the public domain by waiving all of his rights to the work
 * worldwide under copyright law, including all related and
 * neighboring rights, to the extent allowed by law.
 *
 * More information: http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Code style:
 * https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml */

/* These two constants are used when creating new SVG elements and the
 * href attribute linking them to each other.
 */

var svgNs   = 'http://www.w3.org/2000/svg';
var xlinkNs = 'http://www.w3.org/1999/xlink';

/**
 * Stores everything about the map. The element members point to the
 * SVG elements where we'll be adding stuff. We need multiple elements
 * because that's how we make sure that they are painted in the
 * correct order -- a sort of primitive z-axis. The ui Element is a
 * transparent overlay where we'll register the mouse event handlers.
 *
 * If you want to change the size of the map, simply change width and
 * height. 30x30 was the template for the first One Page Dungeon
 * Contest. The tileWidth is the size of one square, in pixels. You
 * can change that as well. Everything shold be scaled accordingly
 * (including the help screen).
 */
var Map = {
  width: 30, // how many columns
  height: 30, // how many rows
  tileWidth: 20, // tile size in pixels
  ui: null, // the SVG element with the event handlers
  pointer: null, // the SVG element for the current position
  levelsElement: null, // the SVG element for levels
  levels: [], // data array of level data (Tiles)
  level: 0, // the current level
  data: null, // the current level data (Tiles)
  floorElement: null, // the SVG element for the floor of the current level
  wallsElement: null, // the SVG element for the walls of the current level
  labelsElement: null, // the SVG element for the labels of the current level
  hideOthers: false, // are the other levels hidden?
  
  /**
   * Initializes the datastructures if necessary. We only need to run
   * this at the very beginning. This does not reset the map in case
   * we're loading an existing file.
   */
  initialize: function() {
    Map.pointer = document.getElementById('pointer');
    Map.levelsElement = document.getElementById('levels');
    // http://javascript.info/tutorial/mouse-events#drag-n-drop
    Map.ui = document.getElementById('ui'); // will be moved, too
    Map.ui.ondragstart = function() { return false };
    Map.ui.onmousedown = penDown;
    Map.ui.onmousemove = Pen.update;
    // http://javascript.info/tutorial/keyboard-events
    Map.exportarea = document.getElementById('exportarea');
    document.onkeydown = keyPressed; // capture arrow keys
    document.onkeypress = keyPressed; // capture character keys
    Map.symbolInit();
  },

  /**
   * Reset the map. This collects the minimum we need to clean
   * everything up. We run this code before starting the demo, for
   * example. There is no undo.
   */
  reset: function() {
    Commands.reset();
    while (Map.levelsElement.lastChild) 
      Map.levelsElement.removeChild(Map.levelsElement.lastChild);
    Map.levels = [];
    createLevel(0);
    Map.setLevel(0);
    Map.showLevelAnimation(0);
    moveElements();
  },
  
  /**
   * Grows the data structures along the x axis, if necessary.
   * Animate the process.
   */
  growWithAnimation: function(to_x) {
    if (to_x >= Map.width) {
      Map.width = to_x + 1;
      moveElements();
    }
  },

  /**
   * Sets the current level. Use this when interpreting code.
   */
  setLevel: function(z) {
    if (!Map.levels[z]) {
      createLevel(z);
    }
    Map.level = z;
    Map.floorElement = document.getElementById('floor' + z);
    Map.wallsElement = document.getElementById('walls' + z);
    Map.labelsElement = document.getElementById('labels' + z);
    Map.data = Map.levels[z];
    document.getElementById('level').textContent = z < 665 ? z + 1: 'The End';
  },

  /**
   * Switch to the indicated level, slowly. This is what we call when
   * the user wants to change level. Usually to_z only differs from
   * Map.level by 1.
   */
  show: function(to_z) {
    var from_z = Map.level;
    if (to_z !== from_z) {
      if (to_z > Map.level) {
        Map.level++;
      } else {
        Map.level--;
      }
      Commands.do(
        function() {
          Map.setLevel(from_z);
          Map.showLevelAnimation();
        },
        function() {
          Map.setLevel(Map.level);
          Map.showLevelAnimation();
        });
      // continue if we haven't reached the target
      if (Map.level !== to_z) {
        Map.show(to_z);
      }
    }
  },

  /**
   * Switch to the indicated level, quickly. This is what we call when
   * setting the level from code and when jumping back to 0. But
   * here's the special case: when doing and undoing this, we want to
   * skip the animation. Then call Map.showLevelAnimation, once.
   */
  jump: function(to_z) {
    var from_z = Map.level;
    if (to_z !== from_z) {
      // push without doing
      Commands.push(
        function() {
          Map.setLevel(from_z);
          Map.showLevelAnimation();
        },
        function() {
          Map.setLevel(to_z);
          Map.showLevelAnimation();
        });
      // just do this
      Map.setLevel(to_z);
    }
  },

  /**
   * Shows all the levels as appropriate, with animation.
   */
  showLevelsTs: null,
  showLevelAnimation: function() {
    // animate it, smoothing it out
    var now = new Date();
    var duration = 500;
    if (Map.showLevelsTs !== null && Map.showLevelsTs > now) {
      setTimeout(Map.showLevelAnimation, Map.showLevelsTs - now);
    } else {
      Map.showLevelsTs = now - (- duration);
      for (var z = 0, map = null; map = document.getElementById('level'+z); z++) {
        if (z === Map.level + 2) {
          fadeElementTo(map, 0.1, linear, duration);
        } else if (z === Map.level + 1) {
          fadeElementTo(map, 0.2, linear, duration);
        } else if (z === Map.level) {
          fadeElementTo(map, 1, linear, duration);
        } else if (z === Map.level - 1) {
          fadeElementTo(map, 0.1, linear, duration);
        } else {
          var opacity = map.hasAttribute('opacity') ? Number(map.getAttribute('opacity')) : 1;
          if (opacity !== 0) {
            fadeElementTo(map, 0, linear, duration);
          }
        }
      }
    }
  },

  /**
   * Hide all the other levels.
   */
  hideOtherLevels: function() {
    // animate it
    var duration = 500;
    for (var z = 0, map = null; map = document.getElementById('level'+z); z++) {
      if (z === Map.level) {
        fadeElementTo(map, 1, linear, duration);
      } else {
        var opacity = Number(map.getAttribute('opacity'));
        if (opacity !== 0) {
          fadeElementTo(map, 0, linear, duration);
        }
      }
    }
  },

  /**
   * Lists the replacement for a particular tile type.
   * This mapping must match the functionality of Map.code.
   */
  variants: {
    'stair': 'stair-small',
    'stair-small': 'stair-spiral',
    'stair-spiral': 'stair-big-spiral',
    'stair-big-spiral': 'stair-big',
    'stair-big': 'stair',
    'door': 'secret',
    'secret': 'concealed',
    'concealed': 'gate',
    'gate': 'door',
  },

  symbols: null,

  symbolInit: function(){
    var map = {
      door: 'd', wall: 'w', stair: 's',
      trap: 't', empty: 'f', pillar: 'p', statue: 'b', diagonal: 'n',
    };
    var keys = Object.keys(map);
    for (var i = 0; i < keys.length; i++) {
      var first = keys[i];
      var sym = map[first];
      for (var next = Map.variants[first]; next !== undefined && next !== first; next = Map.variants[next]) {
        sym += 'v';
        map[next] = sym;
      }
    }
    Map.symbols = map;
  },
  
  /**
   * Produces the code necessary to reproduce the map. The characters
   * must be handled by interpretCont and keyPressed.
   */
  code: function() {
    var source = '';
  
    for (var y = 0; y < Map.height; y++) {
      for (var x = 0; x < Map.width; x++) {
        if (Map.data.has(x, y)) {

          var walls = Map.data.get(x, y).walls;
          if (walls) {
            walls = walls.sort(function(a,b){
              return parseInt(a.getAttribute('rotate')) - parseInt(b.getAttribute('rotate'));
            });
            for (var i = 0; i < walls.length; i++) {
              var tile = walls[i];
              var type = Map.symbols[tile.type];
              if (type) {
                source += type[0].repeat(1 + tile.getAttribute('rotate') / 90 - i) + type.substr(1);
              }
              if (i < walls.length - 1)
                source += '.';
            }
          }
          
          // label must precede floor tiles which advance the position
          var label = Map.data.get(x, y).label;
          if (label)
            source += label.textContent;
          
          var tile = Map.data.get(x, y).floor;
          if (tile !== null) {
            if (tile.hasAttribute('rotate')) {
              var rotate = tile.getAttribute('rotate') / 90;
              var type = Map.symbols[tile.type];
              source += type[0].repeat(1 + rotate) + type.substr(1);
            } else {
              source += Map.symbols[tile.type];
            }
            // the only floor tile that auto-advances is the empty floor
            if (tile.type !== 'empty')
              source += ' ';
          } else {
            source += ' ';
          }
        } else {
          source += ' ';
        }
      }
      source += '\n';
    }
    source = source.replace(/ +$/gm,'');
    source = source.replace(/\n+$/,'');
    source = source.replace(/^(\n*)( *)/, function(match, ys, xs) {
      if (match.length > 5) {
        return '(' + xs.length + ',' + ys.length + ')';
      } else {
        return match;
      }
    });
    return source;
  },
};

/**
 * Provides a matrix of Tiles. If you use the get method on
 * coordinates where no Tile exists, a new one will be created.
 */
function Tiles() {
  this.data = [];
};

Tiles.prototype.get = function(x, y) {
  if (!this.data[x]) {
    this.data[x] = [];
  }
  if (!this.data[x][y]) {
    this.data[x][y] = new Tile();
  }
  return this.data[x][y];
}

Tiles.prototype.has = function(x, y) {
  return this.data[x] && this.data[x][y];
}

/**
 * Stores everything about a single square and its surrounding walls.
 */
function Tile() {
  this.floor = null;
  this.walls = [];
  this.label = null;
};

/**
 * Holds information about the mouse. We're trying to keep as much of
 * the coordinate messing to ourselves, here. Remember: there is an
 * empty column to the left and an empty row at the top.
 */
var Pen = {
  x: 0,
  y: 0,
  ts: null, // when was the pen last used to draw a door
  type: null, // type of tile we last used
  dir: null, // last movement

  /**
   * Determines the grid position based on a mouse event and returns
   * it. Remember that Wall Mode has one coordinate + 0.5. Also
   * consider that in Wall mode, we need to find a point where the
   * axis changes, "jump a corner".
   */
  position: function(evt) {
    var x = evt.clientX / Map.tileWidth - 1; // empty column on the left
    var y = evt.clientY / Map.tileWidth - 1; // empty row at the top
    if (Pen.type === 'wallMode') {
      var dx = x % 1;
      var dy = y % 1;
      if (Pen.x % 1 !== 0) {
        // on a vertical wall
        if (dx > 0.3 && dx < 0.7 && (dy > 0.8 || dy < 0.2)) {
          return { x: Math.floor(x + 0.5), y: Math.floor(y) + 0.5 };
        }
        // no jumping
        return { x: Math.floor(x + 0.5) - 0.5, y: Math.floor(y) };
      }
      // on a horizontal wall
      if ((dx > 0.8 || dx < 0.2) && dy > 0.3 && dy < 0.7) {
        // jump to a vertical wall
        return { x: Math.floor(x) + 0.5, y: Math.floor(y + 0.5) };
      }
      // no jumping
      return { x: Math.floor(x), y: Math.floor(y + 0.5) - 0.5 };
    }
    // in a square
    return { x: Math.floor(x), y: Math.floor(y) };
  },

  /**
   * Moves the pointer to the current Pen position. If passed a
   * non-null mouse event, determine the new position, first. We call
   * this onmousemove even if we're not drawing because of possible
   * keypress events (which don't come with a position).
   */
  update: function(evt) {
    if (evt) {
      var pos = Pen.position(evt);
      if (Pen.x !== pos.x || Pen.y !== pos.y) {
        Pen.ts = null;
        Pen.x = pos.x;
        Pen.y = pos.y;
      }
    }
    Map.pointer.setAttribute('x', (Pen.x + 1) * Map.tileWidth);
    Map.pointer.setAttribute('y', (Pen.y + 1) * Map.tileWidth);
  },

  /**
   * Moves the Pen one step closer to the target position. Returns
   * true if the Pen moved, returns false if the Pen is already at
   * the target. As Wall Mode means that one of the coordinates is
   * off by half, this needs special consideration.
   */
  moveTo: function(target) {
    // jump a corner, if necessary
    if (Pen.type === 'wallMode'
        && (Math.abs(Pen.x - target.x) == 0.5
           || Math.abs(Pen.y - target.y) == 0.5)) {
      Pen.x += target.x > Pen.x ? 0.5 : -0.5;
      Pen.y += target.y > Pen.y ? 0.5 : -0.5;
      return true;
    } else if (Pen.x != target.x) {
      Pen.x += target.x > Pen.x ? 1 : -1;
      return true;
    } else if (Pen.y != target.y) {
      Pen.y += target.y > Pen.y ? 1 : -1;
      return true;
    }
    return false;
  },
};

/**
 * Maintains an undo and a redo list. Whenever you do something that
 * the user can undo, you need to call Commands.do with two
 * functions, the how-to-undo-it step and the how-to-do-it step.
 * how-to-do-it will be called once on order to do it. When the user
 * undoes something, our index is decremented and we execute the
 * appropriate undo step. When the user redoes something, our index is
 * incremented and we execute the appropriate redo step. If the user
 * has undone some steps and then pushes new commands, we discard the
 * steps we have undone.
 */
var Commands = {
  i: -1, // where are we in the undo/redo chain
  undoSteps: [],
  redoSteps: [],

  /**
   * Add two closures to the lists. The first one is how to undo a
   * change, the second one is how to do a change.
   */
  push: function(undoStep, redoStep) {
    // once we're pushing new steps, discard the undone steps
    while (this.undoSteps.length - 1 > this.i) {
      this.undoSteps.pop();
      this.redoSteps.pop();
    }
    this.undoSteps.push(undoStep);
    this.redoSteps.push(redoStep);
    this.i++;
  },
  
  /**
   * Add two closures to the lists. The first one is how to undo a
   * change, the second one is how to do a change. This automatically
   * does the change, too.
   */
  do: function(undoStep, redoStep) {
    Commands.push(undoStep, redoStep);
    redoStep();
  },
  
  undo: function() {
    if (this.i >= 0) {
      this.undoSteps[this.i--]();
    }
  },
  
  redo: function() {
    if (this.i < this.redoSteps.length - 1) {
      this.redoSteps[++this.i]();
    }
  },
  
  reset: function() {
    undoSteps = [];
    redoSteps = [];
  }
};

/**
 * The user interface code for running a demo. The actual demo is
 * scripted in SVG element with the 'messages' id. Each step of the
 * element makes the tspan elements with matching class visible. If
 * there is a code element with a matching class, its text content is
 * interpreted as a script.
 */
var Demo = {

  /**
   * Stores the code to be run on a timer.
   */
  running: null,

  /**
   * Stores the element containing all the steps.
   */
  element: null,

  /**
   * Allows the user to run the demo.
   */
  start: function () {
    Demo.link('Reset map and run demo', 'Demo.run()', true);
  },

  /**
   * Changes the demo link to something else.
   */
  link: function (text, js, revert) {
    var link = document.getElementById('demo');
    var oldText = link.firstElementChild.firstChild.nodeValue;
    link.firstElementChild.firstChild.nodeValue = text;
    var href = link.getAttributeNS(xlinkNs, 'href');
    link.setAttributeNS(xlinkNs, 'href', 'javascript:' + js);
    // reset after 2s
    if (revert)
      var t = setInterval(function() {
        if (!Demo.running) {
          link.setAttributeNS(xlinkNs, 'href', href);
          link.firstElementChild.firstChild.nodeValue = oldText;
          clearInterval(t);
        }
      }, 2000);
  },

  /**
   * Demo the application.
   */
  run: function () {
    Map.reset();
    Pen.x = 0;
    Pen.y = 0;
    Demo.running = true;
    Demo.link('Click to stop demo', 'Demo.stop()', false);
    Map.ui.onmousemove = null;
    Map.ui.onmousedown = null;
    Demo.element = document.getElementById('messages');
    var help = document.getElementById('help').firstElementChild;
    moveElement(Demo.element,
                Demo.element.getBBox().x,
                Demo.element.getBBox().y,
                (Map.width + 2) * Map.tileWidth,
                parseInt(help.getAttribute('height')) + 1.8 * Map.tileWidth,
                bounceEaseOut);
    Demo.step(1);
  },

  /**
   * Let the demo know that we want to abort.
   */
  stop: function () {
    clearInterval(Demo.running);
    Demo.running = null;
    Demo.clean(null);
    wallModeOff();
    Map.ui.onmousemove = Pen.update;
    Map.ui.onmousedown = penDown;
    Demo.link('Abort! Abort!', 'void', false);
  },

  /**
   * Hides elements from a particular step. Usually called for the previous step.
   */
  clean: function(step) {
    var elements = step
        ? Demo.element.getElementsByClassName('step' + step)
        : Demo.element.childNodes;
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].nodeType === Node.ELEMENT_NODE) // IE 11 has no children
        elements[i].setAttribute('visibility', 'collapse');
    }
  },
  
  /**
   * Demo one step and timeout. Note that it's confusing to have more
   * than one code element per step. These are started in order, but
   * if one of them starts delaying using ';', later code will
   * continue executing.
   */
  step: function (step) {
    Demo.clean(step - 1);
    var wait = 5000;
    // show elements for this step and run its code
    elements = Demo.element.getElementsByClassName('step' + step);
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].nodeName === 'tspan') {
        elements[i].setAttribute('visibility', 'visible');
      } else if (elements[i].nodeName === 'code') {
        var code = elements[i].textContent;
        if (code) {
          // Add a delay for every ';' in the code.
          var z = code.match(/;/g);
          if (z)
            wait += 500 * z.length;
          interpret(code);
        }
      }
    }
    // if there was a step, schedule the next step; else quit
    if (elements.length > 0) {
      Demo.running = setTimeout(function() {
        Demo.step(step + 1);
      }, wait);
    } else {
      Demo.stop();
    }
  },
}

/**
 * Defining repeat for Strings, for Chrome/Mac Version 40.0.2214.111
 * (64-bit) as suggested on
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
 */
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    'use strict';
    if (this == null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count != count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count == Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length == 0 || count == 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (august 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count == 0) {
        break;
      }
      str += str;
    }
    return rpt;
  }
}

/* The animation code is taken from these examples:
 * http://javascript.info/tutorial/animation
 */
function animate (opts) {
  var start = new Date();
  var id = setInterval(function() {
    var timePassed = new Date() - start;
    var progress = timePassed / opts.duration;
    if (progress > 1) progress = 1;
    var delta = opts.delta(progress);
    opts.step(delta);
    if (progress === 1) {
      clearInterval(id);
    }
  }, opts.delay || 10);
}

function linear (progress) {
  return progress;
}

function inverse (progress) {
  return 1 - progress;
}

function bounce (progress) {
  for(var a = 0, b = 1; 1; a += b, b /= 2) {
    if (progress >= (7 - 4 * a) / 11) {
      return -Math.pow((11 - 6 * a - 11 * progress) / 4, 2) + Math.pow(b, 2)
    }
  }
}

function makeEaseOut (delta) {
  return function(progress) {
    return 1 - delta(1 - progress);
  }
}

var bounceEaseOut = makeEaseOut(bounce);

function resizeElement (element, toWidth, toHeight, delta, duration) {
  var fromWidth  = element.getBBox().width;  // assuming px
  var fromHeight = element.getBBox().height; // assuming px
  animate({
    delay: 10,
    duration: duration || 1000, // 1 sec by default
    delta: delta,
    step: function(delta) {
      element.setAttribute('width',  fromWidth  + (toWidth  - fromWidth)  * delta);
      element.setAttribute('height', fromHeight + (toHeight - fromHeight) * delta);
    }
  })
}

function moveElement (element, x1, y1, x2, y2, delta, duration) {
  var re = /translate\(.*?\)/;
  var currentX = element.currentX || x1;
  var currentY = element.currentY || y1;
  var oldDx = currentX - x1;
  var oldDy = currentY - y1;
  var newDx = x2 - currentX;
  var newDy = y2 - currentY;
  element.currentX = x2;
  element.currentY = y2;
  if (newDx != 0 || newDy != 0)
    animate({
      delay: 10,
      duration: duration || 1000, // 1 sec by default
      delta: delta,
      step: function(delta) {
        var transform = 'translate(' + (oldDx + newDx * delta) + ',' + (oldDy + newDy * delta) + ')';
        if (!element.hasAttribute('transform'))
          element.setAttribute('transform', transform);
        else if (element.getAttribute('transform').match(re))
          element.setAttribute('transform', element.getAttribute('transform').replace(re, transform));
        else
          element.setAttribute('transform', element.getAttribute('transform') + ',' + transform);
      }
    })
}

function fadeElementTo (element, opacity, delta, duration) {
  var from = element.hasAttribute('opacity') ? Number(element.getAttribute('opacity')) : 1;
  animate({
    delay: 10,
    duration: duration || 1000, // 1 sec by default
    delta: delta,
    step: function(delta) {
      var value = from + (opacity - from) * delta;
      if (value > 0.99) {
        element.removeAttribute('opacity');
      } else {
        element.setAttribute('opacity', value);
      }
    }
  });
};

function moveElements () {
  Map.ui.setAttribute('x', Map.tileWidth);
  Map.ui.setAttribute('y', Map.tileWidth);
  Map.ui.setAttribute('width',  Map.width * Map.tileWidth);
  Map.ui.setAttribute('height', Map.height * Map.tileWidth);
  for (var child = document.getElementById('background').firstElementChild;
       child; child = child.nextElementSibling) {
    resizeElement(child,
                  Map.width * Map.tileWidth,
                  Map.height * Map.tileWidth,
                  linear, 600);
    moveElement(child,
                parseInt(child.getAttribute('x')),
                parseInt(child.getAttribute('y')),
                Map.tileWidth, // an empty column to the left
                Map.tileWidth, // an empty column at the top
                linear, 500);
  }
  var scale = Map.tileWidth / 20;
  var help = document.getElementById('help');
  if (scale != 1) {
    // from now on, we need to scale all coordinates!
    if (help.hasAttribute('transform')) {
      help.setAttribute('transform', help.getAttribute('transform').replace(/scale\(.*?\)/, 'scale('+scale+','+scale+')'));
    } else {
      help.setAttribute('transform', 'scale('+scale+','+scale+')');
    }
  }
  moveElement(help,
              help.getBBox().x,
              help.getBBox().y,
              // an empty column, the background, and another empty column to the left
              (Map.width + 2) * Map.tileWidth / scale,
              // an empty column at the top
              Map.tileWidth / scale,
              linear, 500);
}

/**
 * Offer the current document for download. We store the entire
 * document in a data URI and offer it for downlod using the HTML5
 * download attribute. Chrome 40 will still load that file instead of
 * downloading it. Perhaps a namespace issue? After all, there is no
 * such download attribute for SVG or XHTML.
 */
function download () {
  var source = btoa('<?xml version="1.0" standalone="no"?>\n' +
                    '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
                    '<svg version="1.1"\n' +
                    '     xmlns="http://www.w3.org/2000/svg"\n' +
                    '     xmlns:xlink="http://www.w3.org/1999/xlink">' +
                    // handle Unicode characters
                    unescape(encodeURIComponent(document.documentElement.innerHTML)) +
                    '</svg>');
  var link = document.getElementById('download');
  var text = link.firstElementChild.firstChild.nodeValue;
  link.firstElementChild.firstChild.nodeValue = 'Download';
  var href = link.getAttributeNS(xlinkNs, 'href');
  link.setAttribute('download', 'gridmapper.svg');
  link.setAttributeNS(xlinkNs, 'href', 'data:image/svg+xml;base64,' + source);
  // reset after 10s
  var t = setInterval(function() {
    link.setAttributeNS(xlinkNs, 'href', href);
    link.firstElementChild.firstChild.nodeValue = text;
    clearInterval(t);
  }, 10000);
}

/**
 * Stores the entire document in a link for the user to click.
 */
function prepareLink () {
  var link = document.getElementById('export');
  var text = link.firstElementChild.firstChild.nodeValue;
  link.firstElementChild.firstChild.nodeValue = 'Link';
  var href = link.getAttributeNS(xlinkNs, 'href');
  var location = window.location.href.substr(
    0, window.location.href.length - window.location.search.length)
  link.setAttributeNS(xlinkNs, 'href', location
                      + '?' + encodeURIComponent(getSource()));
  // reset after 10s
  var t = setInterval(function() {
    link.setAttributeNS(xlinkNs, 'href', href);
    link.firstElementChild.firstChild.nodeValue = text;
    clearInterval(t);
  }, 10000);
}

/**
 * Exports the entire document in the text area.
 */
function textExport () {
  Map.exportarea.value = getSource();
}

/**
 * Exports the code in the text area.
 */
function textImport () {
  interpret(Map.exportarea.value);
  Map.showLevelAnimation();
  Pen.update(null);
}

/**
 * Stores the entire document in a sequence of keystrokes with which
 * to recreate it.
 */
function getSource () {
  // do we need to export the map below
  var source = '';
  var level = Map.level;
  for (var z = 0, map = null; map = document.getElementById('level'+z); z++) {
    if (z > 0)
      source += 'z';
    Map.setLevel(z);
    source += Map.code();
  }
  Map.level = level; // reset
  source = source.replace(/zz+/,'z');
  source = source.replace(/^z+/,'');
  source = source.replace(/z+\w*$/,'');
  return source;
}

/**
 * Scales all the tiles in the defs element of the SVG. You can add
 * more tiles at whatever scale you want and this code will determine
 * the scale by comparing your tile's width with the tile width in use
 * by the map. The original tiles are all based on a 10x10 grid and
 * are scaled up to 20x20, for example. The easiest way to do this is
 * to use a <g> element and give it an appropriate width attribute.
 */
function scaleTiles () {
  var tiles = document.getElementsByTagName('defs')[0].childNodes;
  for (var i = 0; i < tiles.length; ++i) {
    if (tiles[i].nodeType === Node.ELEMENT_NODE
        && tiles[i].hasAttribute('width')) {
      var scale = Map.tileWidth / tiles[i].getAttribute('width');
      if (scale != 1) {
        tiles[i].setAttribute('transform', 'scale('+scale+','+scale+')');
      }
    }
  }
}

/**
 * Creates a new tile. These tiles are use elements in the SVG
 * referring to an existing definition of the given type. An
 * appropriate id attribute is also generated.
 */
function createTile (x, y, type) {
  var tile = document.createElementNS(svgNs, 'use');
  tile.setAttribute('id', type + '_' + x + '_' + y);
  tile.setAttribute('x', (x + 1) * Map.tileWidth); // empty column to the left
  tile.setAttribute('y', (y + 1) * Map.tileWidth); // empty row at the top
  tile.type = type;
  tile.setAttributeNS(xlinkNs, 'href', '#' + type);
  return tile;
}

/**
 * Add s to the label at (x,y).
 */
function addToLabel(x, y, s) {
  var tile = Map.data.get(x, y).label;
  var text = null;
  if (tile === null) {
    tile = document.createElementNS(svgNs, 'text');
    tile.setAttribute('id', 'label' + '_' + x + '_' + y);
    tile.setAttribute('x', (x + 1.5) * Map.tileWidth); // empty column to the left
    tile.setAttribute('y', (y + 1.7) * Map.tileWidth); // empty row at the top, + lineheight
    tile.setAttribute('style', 'text-anchor: middle'); // centered
    text = tile.textContent;
  }
  Commands.do(
    function(){
      if (text === s) {
        Map.labelsElement.removeChild(tile);
        Map.data.get(x, y).label = null;
      } else {
        tile.textContent = tile.textContent.substr(0, tile.textContent.length - 1);
      }
    },
    function(){
      if (text === "") {
        Map.labelsElement.appendChild(tile);
        Map.data.get(x, y).label = tile;
      }
      tile.textContent += s;
    });
}

/**
 * Remove the last character from the label at (x,y).
 * Returns true if there was text to delete.
 */
function deleteFromLabel(x, y) {
  var tile = Map.data.get(x, y).label;
  if (tile !== null) {
    var text = tile.textContent;
    if (text !== "") {
      Commands.do(
        function(){
          if (text.length === 1) {
            Map.labelsElement.appendChild(tile);
            Map.data.get(x, y).label = tile;
          }
          tile.textContent = text;
        },
        function(){
          tile.textContent = tile.textContent.substr(0, tile.textContent.length - 1);
          if (tile.textContent === "") {
            Map.labelsElement.removeChild(tile);
            Map.data.get(x, y).label = null;
          }
        });
      return true;
    }
  }
}


/**
 * Returns an unused angle for wall tiles. Provide a preferred angle.
 * Possible values are 0, 90, 180, 270.
 */
function getUnusedAngle (x, y, rotate) {
  var candidate = [rotate,
                   (rotate + 90) % 360,
                   (rotate + 180) % 360,
                   (rotate + 270) % 360];
  var existingWalls = [];
  var walls = Map.data.get(x, y).walls;
  for (var i = 0; i < walls.length; i++) {
    existingWalls.push(walls[i].getAttribute('rotate'));
  }
  search: for (var c = 0; c < 4; c++) {
    for (var i = 0; i < existingWalls.length; i++) {
      if (candidate[c]==existingWalls[i]) {
        continue search;
      }
    }
    return candidate[c];
  }
}

/* Drawing on the walls */

/**
 * Transforms the given tile such that it is rotated by the given
 * angle.
 */
function rotateTile (tile, type, x, y, angle) {
  tile.setAttribute('rotate', angle);
  if (angle === 180 && type === 'concealed') {
    tile.setAttribute('transform', 'translate('+Map.tileWidth+',0)');
  } else if (angle > 0) {
    var cx = (x + 1.5) * Map.tileWidth; // empty column to the left
    var cy = (y + 1.5) * Map.tileWidth; // empty row at the top
    tile.setAttribute('transform', 'rotate('+angle+','+cx+','+cy+')');
  } else {
    tile.removeAttribute('transform');
  }
}

/**
 * Places a tile of the given type on a free section of the wall
 * around the given square.
 */
function wallPlacement (x, y, type) {
  var now = new Date();
  var walls = Map.data.get(x, y).walls;
  if (Pen.type === type
      && walls  && walls.length > 0
      && Pen.ts && now - Pen.ts <= 2000) {
    // we just placed a door: take the last one and rotate it
    var tile = walls[walls.length - 1];
    var old = tile.getAttribute('transform');
    var angle = parseInt(tile.getAttribute('rotate'));
    var rotate = getUnusedAngle(x, y, (angle + 90) % 360);
    if (rotate != null) {
      Commands.do(
        function(){
          rotateTile(tile, type, x, y, angle);
        },
        function(){
          rotateTile(tile, type, x, y, rotate);
        });
    }
  } else {
    var rotate = getUnusedAngle(x, y, 0);
    if (rotate != null) {
      var tile = createTile(x, y, type);
      rotateTile(tile, type, x, y, rotate);
      Commands.do(
        function(){
          walls.pop();
          Map.wallsElement.removeChild(tile);
        },
        function(){
          walls.push(tile);
          Map.wallsElement.appendChild(tile);
        });
    }
  }
  Pen.ts = now;
}

/**
 * Draws a wall tile of the given type on the current wall. The
 * current wall only makes sense in Wall Mode. In Wall Mode, one of
 * the two coordinates is +0.5. We determine the angle (0 or 90) and
 * put a tile there.
 */
function wallDraw (x, y, type) {
  var angle = 0;
  if (y % 1 === 0) {
    x = Math.ceil(x);
  } else {
    angle = 90;
    y = Math.ceil(y);
  }
  var i, old;
  var tile = createTile(x, y, type);
  var walls = Map.data.get(x, y).walls;
  rotateTile(tile, type, x, y, angle)
  for (i = 0; i < walls.length; i++) {
    if (parseInt(walls[i].getAttribute('rotate')) == angle) {
      old = walls[i];
      break;
    }
  }
  Commands.do(
    function(){
      Map.wallsElement.removeChild(tile);
      if (old) {
        Map.wallsElement.appendChild(old);
        walls[i] = old;
      } else {
        walls.pop();
      }
    },
    function(){
      if (old) {
        Map.wallsElement.removeChild(old);
        walls[i] = tile;
      } else {
        walls.push(tile);
      }
      Map.wallsElement.appendChild(tile);
    });
}

/**
  * Toggles Wall Mode.
  */
function wallMode (x, y) {
  if (Pen.type === 'wallMode') {
    wallModeOff();
  } else {
    Pen.type = 'wallMode';
    if (Pen.x > 0) {
      Pen.x -= 0.5;
    } else {
      Pen.x += 0.5;
    }
  }
  Pen.update(null);
}

/**
 * Places a tile of the given type in the given square. If in Wall
 * Mode, use the given wall. Otherwise, find a free section around the
 * given square.
 */
function wall (x, y, type) {
  if (Pen.type === 'wallMode') {
    wallDraw(x, y, type);
  } else {
    wallPlacement(x, y, type);
    Pen.type = type;
  }
}

/**
 * Finds a wall tile for the current position of a given angle in wall
 * mode and return its index in the wall array. You're meant to call
 * this multiple times: Once for (x, y) where the angle could be 0° or
 * 90°, once for (x-1, y) where the angle could be 180° and once for
 * (x, y-1) where the angle could be 270°.
 */
function findWall (walls, angle) {
  for (var i = 0; i < walls.length; i++) {
    if (parseInt(walls[i].getAttribute('rotate')) == angle) {
      return i;
    }
  }
  return null;
}

/**
 * Removes a tile from the surrounding walls of the give tile.
 * Returns true if there was a wall.
 */
function removeWall (x, y) {
  var angle = 0;
  if (Pen.type === 'wallMode') {
    if (y % 1 === 0) {
      x = Math.ceil(x);
    } else {
      angle = 90;
      y = Math.ceil(y);
    }
  }
  var walls = Map.data.get(x, y).walls;
  var i;
  if (Pen.type === 'wallMode') {
    i = findWall(walls, angle);
    if (i === null && angle === 0 && x > 0) {
      walls = Map.data.get(x - 1, y).walls;
      i = findWall(walls, 180);
    }
    if (i === null && angle === 90 && y > 0) {
      walls = Map.data.get(x , y - 1).walls;
      i = findWall(y - 1, y, 270);
    }
  } else {
    i = walls.length - 1;
  }
  if (i != null && i >= 0) {
    var old = walls[i];
    Commands.do(
      function(){
        Map.wallsElement.appendChild(old);
        walls.push(old);
      },
      function(){
        Map.wallsElement.removeChild(old);
        walls.splice(i,1);
      });
    return true;
  }
}

/**
 * Draws a tile on the floor. If the tile it already there, draws
 * floor instead. Stairs are taken care of---they are on a different
 * layer!
 */
function draw (x, y, type) {
  var old = Map.data.get(x, y).floor;
  if (old != null && old.type === type) {
    floor(x, y);
  } else {
    replaceFloor(x, y, old, createTile(x, y, type));
  }
}

/**
 * Replaces the old tile on the floor with a new tile. The code
 * handles both the old tile and the new tile being null.
 * If both are null, nothing needs to be done.
 */
function replaceFloor(x, y, old, tile) {
  if (old !== null || tile !== null) {
    Commands.do(
      function(){
        if (tile)
          Map.floorElement.removeChild(tile);
        if (old)
          Map.floorElement.appendChild(old);
        Map.data.get(x, y).floor = old;
      },
      function(){
        if (old) {
          Map.floorElement.removeChild(old);
        }
        if (tile)
          Map.floorElement.appendChild(tile);
        Map.data.get(x, y).floor = tile;
      });
  }
}

/**
 * Returns the number of steps required to turn b into variant a. If a
 * is not a variant of b, returns undefined. From stairs to stairs is
 * 0, so this is not truthy! Use isVariantOf if you need that.
 */
function variantOf(a, b) {
  if (a === b)
    return 0;
  var matches = {};
  for (var next = b, i = 1; next !== undefined && Map.variants[next] !== b; next = Map.variants[next], i++) {
    matches[next] = i;
  }
  return matches[a];
}

/**
 * Returns whether a is a variant of b.
 */
function isVariantOf(a, b) {
  if (a === b)
    return true;
  return variantOf(a, b) !== undefined;
}

/**
 * Replaces the last tile placed with a variant thereof.
 */
function variant (x, y) {
  var tile;
  if (Pen.type === 'wallMode') {
    if (y % 1 === 0) {
      x = Math.ceil(x);
    } else {
      y = Math.ceil(y);
    }
  }
  tile = Map.data.get(x, y).floor;
  if (Pen.type === 'wallMode'
      || isVariantOf(Pen.type, 'door')
      || tile !== null && Map.variants[tile.type] === undefined) {
    var walls = Map.data.get(x, y).walls;
    tile = walls[walls.length - 1];
  }
  if (tile) {
    var old = tile.type;
    var type = Map.variants[tile.type];
    if (type) {
      Commands.do(
        function(){
          tile.type = old;
          tile.setAttribute('id', old + '_' + x + '_' + y);
          tile.setAttributeNS(xlinkNs, 'href', '#' + old);
        },
        function(){
          tile.type = type;
          tile.setAttribute('id', type + '_' + x + '_' + y);
          tile.setAttributeNS(xlinkNs, 'href', '#' + type);
        });
    }
  }
}

/**
 * Draws stairs and diagonals on the floor.
 */
function floorRotate (x, y, type) {
  var old = Map.data.get(x, y).floor;
  if (old && isVariantOf(old.type, type) !== null && old.hasAttribute('rotate')) {
    var angle = parseInt(old.getAttribute('rotate'));
    Commands.do(
      function(){
        rotateTile(old, type, x, y, angle);
      },
      function() {
        rotateTile(old, type, x, y, (angle + 90) % 360);
      });
  } else {
    var tile = createTile(x, y, type);
    tile.setAttribute('rotate', 0);
    replaceFloor(x, y, old, tile);
  }
}

/**
 * Draws or erases a floor tile.
 */
function floor (x, y) {
  var old   = Map.data.get(x, y).floor;
  if (!old || old.type != 'empty') {
    replaceFloor(x, y, old, createTile(x, y, 'empty'));
  } else {
    replaceFloor(x, y, old, null);
  }
}

/**
 * Ease floor tile, if any.
 */
function removeFloor (x, y) {
  var old   = Map.data.get(x, y).floor;
  if (old)
    replaceFloor(x, y, old, null);
}

/* This is where we draw (or erase) floor tiles. The key point to
 * remember is that we might not get a mouse event for every
 * coordinate. That's why we need to store where we want to draw to
 * (our target) and start drawing at our current position (the pen).
 * We do this at least once in order to support clicks without mouse
 * movement. Then we start a loop: as long as the pen hasn't reached
 * the target, we change x or y by 1 and draw another tile. As we're
 * creating closures for Commands, we need to do this in a factory.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Creating_closures_in_loops.3A_A_common_mistake
 */

function drawToCommand (x, y, tile, type) {
  var remove = function(){
    Map.floorElement.removeChild(tile);
    Map.data.get(x, y).floor = null;
  };
  var add = function(){
    Map.data.get(x, y).floor = tile;
    Map.floorElement.appendChild(tile);
  };
  if (type === 'add') {
    Commands.do(remove, add); // add new tile
  } else {
    Commands.do(add, remove); // remove existing tile
  }
}

function drawTo (evt) {
  var target = Pen.position(evt);
  // draw up to the current position (at least once if we just started)
  do {
    if (!Map.data.get(Pen.x, Pen.y).floor && Pen.type === 'empty') {
      drawToCommand(Pen.x, Pen.y, createTile(Pen.x, Pen.y, 'empty'), 'add');
    } else if (Map.data.get(Pen.x, Pen.y).floor && Pen.type === 'null') {
      drawToCommand(Pen.x, Pen.y, Map.data.get(Pen.x, Pen.y).floor, 'remove');
    }
  } while (Pen.moveTo(target));
  Pen.update(evt);
}

/**
 * Sets the Pen down, ready for drawing. When setting down the pen
 * (onmousedown, penDown), we look at the current tile. If it's the
 * empty floor tile, we'll want to erase it. If there is no floor tile
 * (null), we'll want to draw an empty floor tile. We store this
 * information in the Pen type and as we keep on drawing (onmousemove,
 * drawTo), we don't change it.
 */
function penDown (evt) {
  wallModeOff();
  Pen.update(evt);
  if (Map.data.get(Pen.x, Pen.y).floor) {
    Pen.type = 'null';
  } else {
    Pen.type = 'empty';
  }
  // draw at least one tile
  drawTo(evt);
  // install new handler
  Map.ui.onmousemove = drawTo;
  // revert to pen tracking on mouse up *anywhere*
  document.onmouseup = function() {
    Map.ui.onmousemove = Pen.update;
  }
}

/**
 * Puts the pointer back into a square and ends Wall Mode.
 * Call this whenever you're acting on squares.
 */
function wallModeOff () {
  Pen.x = Math.ceil(Pen.x);
  Pen.y = Math.ceil(Pen.y);
  Pen.update(null);
  Pen.type = null;
}

/**
 * Moves the pointer around. It handles both moving from square to
 * sqare as well as moving from wall to wall (where one of the
 * coordinates is off by 0.5).
 */
function move (dir) {
  switch (dir) {
  case 'left':
    if (Pen.x > 0)
      Pen.x--;
    break;
  case 'right':
    Map.growWithAnimation(Pen.x + 1);
    Pen.x++;
    break;
  case 'up':
    if (Pen.y > 0)
      Pen.y--;
    break;
  case 'down':
    if (Pen.y + 1 >= Map.height) {
      Map.height++;
      moveElements();
    }
    Pen.y++;
    break;
  }
  // Example: when moving down from 1 to 2 and right to 3, we want to
  // switch position on the grid and end up on 4. So we need to adjust
  // the position by (-0.5,-0.5):
  //
  //  x→
  // y  |   |
  // ↓--+---+---
  //    1   |
  //  --+-4-+---
  //    2   3
  //  --+---+---
  //    |   |
  //
  // If we moved first right and then down, we would end up in the same
  // position.
  if (Pen.type === 'wallMode') {
    var now = new Date();
    if (Pen.dir && Pen.ts && now - Pen.ts <= 500) {
      if (Pen.dir=='left' && dir=='down'
          || Pen.dir=='down' && dir=='left') {
        Pen.x += 0.5;
        Pen.y -= 0.5;
      } else if (Pen.dir=='left' && dir=='up'
                 || Pen.dir=='up' && dir=='left') {
        Pen.x += 0.5;
        Pen.y += 0.5;
      } else if (Pen.dir=='right' && dir=='down'
                 || Pen.dir=='down' && dir=='right') {
        Pen.x -= 0.5;
        Pen.y -= 0.5;
      } else if (Pen.dir=='right' && dir=='up'
                 || Pen.dir=='up' && dir=='right') {
        Pen.x -= 0.5;
        Pen.y += 0.5;
      }

    }
  }
  Pen.update(null);
  Pen.dir = dir;
  Pen.ts = now; // must come after Pen.update
}

/**
 * Extract key from KeyboardEvent
 * Basic source from http://javascript.info/tutorial/keyboard-events#processing-the-character-keypress
 */
function getChar(event) {
  if (event.which == null) {
    return String.fromCharCode(event.keyCode) // IE character keys
  } else if (event.which!=0 && event.charCode!=0) {
    return String.fromCharCode(event.which) // the rest character keys
  } else if (event.type == 'keydown') { // special key
    if(event.key && event.key.length != 1) return event.key; // Firefox
    if(event.keyIdentifier && event.keyIdentifier.substring(0,2) !== 'U+') return event.keyIdentifier; // Chrome
    if(event.keyCode === 8) { // Chrome Backspace
      event.preventDefault();
      return 'Backspace';
    }
  }
  return null; // ignore second key event
}

/**
 * Processes key press events and single character strings (in case
 * the interpreter is feeding us some). Many of the key commands need
 * a 'current' position. We determine it by looking at the Pen. It's
 * position is always tracked (onmousemove, Pen.update).
 */
function keyPressed (evt) {
  // Could be a string when running interpreted code.
  var key = evt;

  // When running the demo, ignore key events from the browser.
  if (!Demo.running && evt instanceof KeyboardEvent) {
    key = getChar(evt);
    if(key === null) return; // ignore one of onkeydown or onkeypress event
  }

  if (evt.originalTarget === Map.exportarea) {
    if (key === 'Enter' && evt.ctrlKey) {
      textImport();
    }
    return;
  }

  switch (key) {

  case '?':
    var help = document.getElementById('help');
    if (help.getAttribute('visibility') === 'hidden') {
      help.setAttribute('visibility', 'visible');
    } else {
      help.setAttribute('visibility', 'hidden');
    }
    break;

  case 'u':
    Commands.undo();
    break;

  case 'r':
    Commands.redo();
    break;

  case 'ArrowDown':
  case 'Down':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('down');
    break;

  case 'ArrowUp':
  case 'Up':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('up');
    break;

  case 'ArrowLeft':
  case 'Left':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('left');
    break;

  case 'ArrowRight':
  case 'Right':
  case ' ':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('right');
    break;

  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
  case '0':
    addToLabel(Pen.x, Pen.y, key);
    break;

  case 'Backspace':
  case 'Del':
    if (Pen.type === 'wallMode') {
      if (!removeWall(Pen.x, Pen.y)) {
        wallModeOff();
        deleteFromLabel(Pen.x, Pen.y)
          || removeFloor(Pen.x, Pen.y, null, null);
      }
    } else {
    deleteFromLabel(Pen.x, Pen.y)
      || removeWall(Pen.x, Pen.y)
        || removeFloor(Pen.x, Pen.y, null, null);
    }
    break;

  case 'f':
    wallModeOff();
    floor(Pen.x, Pen.y);
    break;

  case '\n':
  case 'Enter':
    if (evt.ctrlKey) {
      textImport();
    } else {
      wallModeOff();
      Pen.x = 0;
      move('down');
    }
    break;

  case 'd':
    wall(Pen.x, Pen.y, 'door');
    break;

  case 'w':
    wall(Pen.x, Pen.y, 'wall');
    break;

  case 'm':
    wallMode(Pen.x, Pen.y);
    break;

  case 'x':
    removeWall(Pen.x, Pen.y);
    break;

  case 'p':
    wallModeOff();
    draw(Pen.x, Pen.y, 'pillar');
    break;

  case 't':
    wallModeOff();
    draw(Pen.x, Pen.y, 'trap');
    break;

  case 'b':
    wallModeOff();
    draw(Pen.x, Pen.y, 'statue');
    break;

  case 's':
    wallModeOff();
    floorRotate(Pen.x, Pen.y, 'stair');
    break;

  case 'v':
    variant(Pen.x, Pen.y);
    break;

  case 'n':
    wallModeOff();
    floorRotate(Pen.x, Pen.y, 'diagonal');
    break;

  case 'z':
    if (Map.level < 665) {
      Map.show(Map.level + 1);
    }
    break;

  case 'y':
    if (Map.level > 0) {
      Map.show(Map.level - 1);
    }
    break;

  case 'Z':
    if (Map.hideOthers) {
      Map.showLevelAnimation();
    } else {
      Map.hideOtherLevels();
    }
    Map.hideOthers = !Map.hideOthers;
    break;

  default:
    console.log('Gridmapper does not know how to handle "'+ key
                + '" (keyIdentifier: '+evt.keyIdentifier+', keyCode: '+ evt.keyCode+')');
    break;
  }
}

/**
 * Interprets a sequence of characters as a script. A '.' will reset
 * the Pen's timestamp, simulating a pause (to prevent rotating the
 * last tile). A ';' will cause a timeout. This is used for the demo.
 * Since we don't want to freeze the computer, all the heavy lifting
 * is done by another function which knows how to finish the job.
 */
function interpret (code) {
  interpretCont(code, 0);
}

/**
 * Continues the interpretation where we left oft. The variables are
 * not initialized so that we can simply pick up where we left off.
 * This is because we want to interrupt the computation using
 * timeouts.
 */
function interpretCont (code, i) {
  for (; i < code.length; i++) {
    var advance = null;
    switch(code[i]) { // needs charAt?
    case '.': Pen.ts = null; break;
    case ';':
      setTimeout(function() {
        interpretCont(code, i + 1);
      }, 500);
      return; // end!
    case '(':
      var match = code.substr(i).match(/(\d+(?:\.\d+)?),(\d+(?:\.\d+)?)\)/);
      if (match) {
        // no longer ints!
        var x = Number(match[1]);
        var y = Number(match[2]);
        if (Demo.running) {
          if (Pen.moveTo({x: x, y: y})) {
            Pen.update(null);
            setTimeout(function() {
              interpretCont(code, i);
            }, 100);
            return; // end!
          }
        } else {
          Pen.x = x;
          Pen.y = y;
        }
        i += match[0].length;
      }
      break;
    case '[':
      var match = code.substr(i).match(/(-?\d+),(-?\d+)\]/);
      if (match) {
        Pen.x += Number(match[1]);
        Pen.y += Number(match[2]);
        i += match[0].length;
      }
      break;
    case '-':
      advance = 'left';
      break;
    case 'z':
      // When loading from an URL, we need to reposition the Pen, and
      // we want to be quick. When running the Demo, we do not.
      if (Demo.running) {
        Map.show(Map.level + 1);
      } else {
        Pen.x = 0;
        Pen.y = 0;
        Pen.type = null;
        Map.jump(Map.level + 1);
      }
      break;
    case 'f':
      advance = 'right';
      // fall through to default
    default:
      keyPressed(code[i]);
    }
    // advance unless we're going to move elsewhere (peek ahead)
    if (advance && code[i+1] !== '\n' && code[i] !== '(' && code[i] !== '[')
      move(advance);
  }
}

/**
 * Recreates the models based on existing SVG elements (if loading a
 * saved file) and the URL (if loading a page). When loading a file,
 * We go through the elements and add the appropriate data to the
 * various data models. When loading from a URL, we look at the
 * keyword parameter and interpret it as a key sequence one might
 * conceivably type. The only difference is the . character which is
 * used to simulate a little pause (to prevent doors from rotating).
 */
function recreateModel () {
  var re = /^([-a-z]+)_(\d+)_(\d+)$/;
  var z = 0;
  for (var map; map = document.getElementById('level'+z); z++) {
    var data = new Tiles();
    recreateModelFor(re, data, document.getElementById('floor'+z));
    recreateModelFor(re, data, document.getElementById('labels'+z));
    recreateModelForDoors(re, data, document.getElementById('walls'+z));
    Map.levels[z] = data;
  }
  if (z === 0) {
    createLevel(0);
  }
  // skip initial '?', start at level 0
  Map.setLevel(0);
  interpret(decodeURIComponent(window.location.search).substring(1));
  // at the end, move to the top of the dungeon and show it
  Map.jump(0);
  Map.showLevelAnimation();
  moveElements(); // animate grows in the end
}

/**
 * Recreates one particular model based on a matching SVG element.
 * This looks only at id attributes.
 */
function recreateModelFor (re, data, element) {
  for (var child = element.firstElementChild; child; child = child.nextElementSibling) {
    var result = child.getAttribute('id').match(re);
    if (result) {
      child.type = result[1]; // to enable code generation
      var x = result[2];
      var y = result[3];
      if (result[1] === 'label') {
        data.get(x, y).label = child;
      } else {
        data.get(x, y).floor = child;
      }
    }
  }
}

/**
 * Recreates one particular wall model on a matching SVG element.
 * This looks only at id attributes.
 */
function recreateModelForDoors (re, data, element) {
  for (var child = element.firstElementChild; child; child = child.nextElementSibling) {
    var result = child.getAttribute('id').match(re);
    if (result) {
      child.type = result[1]; // to enable code generation
      var x = result[2];
      var y = result[3];
      data.get(x, y).walls.push(child);
    }
  }
}

/**
 * Creates the SVG elements for a level. This must match the
 * expectations in recreateModel.
 */
function createLevel(z) {
  var level = document.createElementNS(svgNs, 'g');
  level.setAttribute('id', 'level' + z);
  var floor = document.createElementNS(svgNs, 'g');
  floor.setAttribute('id', 'floor' + z);
  var labels = document.createElementNS(svgNs, 'g');
  labels.setAttribute('id', 'labels' + z);
  var walls = document.createElementNS(svgNs, 'g');
  walls.setAttribute('id', 'walls' + z);
  level.appendChild(floor);
  level.appendChild(labels);
  level.appendChild(walls);
  Map.levelsElement.insertBefore(level, Map.levelsElement.firstChild);
  Map.levels[z] = new Tiles();
}

/**
 * Initialize the user interface.
 */
function initialize () {
  scaleTiles();
  Map.initialize(); // don't reset the Map so we can load from a file
  Pen.update(null); // show it
  recreateModel(); // create model
}

onload = initialize;
]]></script>
  <defs>
    <rect id="cursor" width="10" height="10" fill="forestgreen" opacity="0.2"/>
    <rect id="empty" width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
    <g id="wall" width="10">
      <line x1="0" y1="0" x2="0" y2="10" stroke="black" stroke-width="3" stroke-linecap="round"/>
    </g>
    <g id="door" width="10">
      <rect x="-1.5" y="2" width="3" height="6" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="secret" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -2,1 -3,5 0,5 S 2,9 -2,7" />
    </g>
    <g id="concealed" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -3,1 -3,9 2,7" />
    </g>
    <g id="gate" width="10">
      <rect x="-2" y="4" width="4" height="12" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="pillar" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="2" fill="black"/>
    </g>
    <g id="statue" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3.5" fill="none" stroke="black" stroke-width="0.5"/>
      <path fill="black" d="M 2,4 H 8 L 3,7.5 5,2 7,7.5 Z"/>
    </g>
    <g id="trap" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="white" stroke="black" stroke-width="1"/>
      <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="diagonal" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <path fill="black" d="M 0,0 H 10 L 0,10 Z"/>
    </g>
    <g id="stair" width="10">
      <rect width="10" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="0" y1="3" x2="10" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="1" y1="6" x2="9" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="9" x2="8" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="12" x2="7" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="15" x2="6" y2="15" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair-small" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <line x1="1" y1="2" x2="9" y2="2" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="4" x2="8" y2="4" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="6" x2="7" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="8" x2="6" y2="8" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair-big" width="10">
      <rect width="20" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="1" y1="3" x2="19" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="6" x2="18" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="9" x2="17" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="12" x2="16" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="5" y1="15" x2="15" y2="15" stroke="black" stroke-width="0.8"/>
      <line x1="6" y1="18" x2="14" y2="18" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair-big-spiral" width="50">
      <rect width="100" height="100" fill="white" stroke="black" stroke-width="5"/>
      <circle cx="50" cy="50" r="40" fill="none" stroke="black" stroke-width="5"/>
      <line x1="0" y1="50" x2="99" y2="50" stroke="black" stroke-width="5"/>
      <line x1="50" y1="0" x2="50" y2="100" stroke="black" stroke-width="5"/>
      <line x1="15" y1="30" x2="85" y2="70" stroke="black" stroke-width="5"/>
      <line x1="15" y1="70" x2="85" y2="30" stroke="black" stroke-width="5"/>
      <line x1="30" y1="15" x2="70" y2="85" stroke="black" stroke-width="5"/>
      <line x1="30" y1="85" x2="70" y2="15" stroke="black" stroke-width="5"/>
      <circle cx="50" cy="50" r="10" fill="white" stroke="black" stroke-width="5"/>
    </g>
    <g id="stair-spiral" width="100">
      <rect width="100" height="100" fill="white" stroke="black" stroke-width="10"/>
      <circle cx="50" cy="50" r="40" fill="none" stroke="black" stroke-width="7"/>
      <line x1="10" y1="50" x2="90" y2="50" stroke="black" stroke-width="7"/>
      <line x1="50" y1="10" x2="50" y2="90" stroke="black" stroke-width="7"/>
      <line x1="22" y1="22" x2="78" y2="78" stroke="black" stroke-width="7"/>
      <line x1="22" y1="78" x2="78" y2="22" stroke="black" stroke-width="7"/>
      <circle cx="50" cy="50" r="10" fill="white" stroke="black" stroke-width="7"/>
    </g>
  </defs>
  <g id="background">
    <rect x="20" y="20" width="0" height="0" fill="lightgrey" stroke="black" stroke-width="1"/>
  </g>
  <g id="levels"/>
  <use id="pointer" xlink:href="#cursor"/>
  <g id="walls"/>
  <rect id="ui" opacity="0"/>

  <style><![CDATA[
  text { font: 14px 'Courier New', Courier, monospace; }
  .labels text, #levels text { font: 10px 'Arial Narrow', sans-serif; font-weight: bold; }
  .key { fill: forestgreen; font-weight: bold; }
  ]]></style>

  <g id="help">
    <rect x="10" y="80" width="440" height="550" fill="ivory" stroke="black" stroke-width="1"/>
    <text id="level" x="460" y="220" style="font:30px 'Arial Narrow', sans-serif; font-weight: bold;">1</text>
    <a xlink:href="https://alexschroeder.ch/wiki/Gridmapper">
      <text x="460" y="90" transform="rotate(90,460,90)" style="font-weight: bold;">Gridmapper</text>
    </a>
    <use x="30" y="90" xlink:href="#empty"/>
    <use x="30" y="120" xlink:href="#trap"/>
    <use x="150" y="120" xlink:href="#pillar"/>
    <use x="290" y="120" xlink:href="#statue"/>
    <use x="30" y="150" xlink:href="#empty"/>
    <use x="30" y="150" xlink:href="#door"/>
    <use x="410" y="150" xlink:href="#empty"/>
    <use x="410" y="170" xlink:href="#empty"/>
    <use x="410" y="150" xlink:href="#gate"/>
    <use x="350" y="150" xlink:href="#empty"/>
    <use x="350" y="150" xlink:href="#secret"/>
    <use x="380" y="150" xlink:href="#empty"/>
    <use x="380" y="150" xlink:href="#concealed"/>
    <use x="30" y="200" xlink:href="#empty"/>
    <use x="30" y="200" xlink:href="#wall"/>
    <use x="30" y="230" xlink:href="#stair"/>
    <use x="390" y="230" xlink:href="#stair-small"/>
    <use x="360" y="230" xlink:href="#stair-spiral"/>
    <use x="340" y="260" xlink:href="#stair-big-spiral"/>
    <use x="390" y="260" xlink:href="#stair-big"/>
    <use x="30" y="280" xlink:href="#diagonal"/>
    <use x="30" y="310" xlink:href="#empty"/>
    <g class="labels">
      <text x="40" y="324" style="text-anchor: middle">123</text>
    </g>
    <use x="20" y="340" xlink:href="#cursor"/>
    <use x="30" y="340" xlink:href="#empty"/>

    <foreignObject x="30" y="560" width="1000" height="2000">
        <textarea xmlns="http://www.w3.org/1999/xhtml" style="background: white; width: 390px; height: 50px; font: 10px 'Courier New', Courier, monospace; " id="exportarea"/>
    </foreignObject>
    
    <text y="105">
      <tspan x="60"><tspan class="key">f</tspan> : floor / erase (like using the mouse)</tspan>
      <tspan x="60" dy="30"><tspan class="key">t</tspan> : trap</tspan>
      <tspan x="180"><tspan class="key">p</tspan> : pillar</tspan>
      <tspan x="320"><tspan class="key">b</tspan> : statue</tspan>
      <tspan x="60" dy="30"><tspan class="key">d</tspan> : a door, repeat to rotate</tspan>
      <tspan x="60" dy="20">    use <tspan class="key">v</tspan> for variants</tspan>
      <tspan x="60" dy="30"><tspan class="key">w</tspan> : wall, repeat to rotate</tspan>
      <tspan x="60" dy="30"><tspan class="key">s</tspan> : stairs, repeat to rotate</tspan>
      <tspan x="60" dy="20">    use <tspan class="key">v</tspan> for variants</tspan>
      <tspan x="60" dy="30"><tspan class="key">n</tspan> : diagonal, repeat to rotate</tspan>
      <tspan x="60" dy="30" class="key">0-9</tspan><tspan> : add labels</tspan>
      <tspan x="60" dy="30" class="key">m</tspan><tspan> : enter / leave Wall Mode</tspan>
      <tspan x="60" dy="20" class="key">x</tspan><tspan> : clear wall</tspan>
      <tspan x="60" dy="20" class="key">u</tspan><tspan> : undo</tspan>
      <tspan x="60" dy="20" class="key">r</tspan><tspan> : redo</tspan>
      <tspan x="60" dy="20" class="key">y</tspan><tspan> : up / </tspan>
      <tspan class="key">z</tspan><tspan> : down</tspan>
      <tspan x="60" dy="20" class="key">Z</tspan><tspan> : hide other levels</tspan>
      <tspan x="60" dy="20" class="key">Delete</tspan><tspan> : delete</tspan>
      <a id="download" fill="blue" xlink:href="javascript:download()">
	<tspan x="30" dy="30">Prepare Download</tspan>
      </a>
      <tspan> / </tspan>
      <a id="export" fill="blue" xlink:href="javascript:prepareLink()">
	<tspan>Prepare Link</tspan>
      </a>
      <tspan> / </tspan>
      <a fill="blue" xlink:href="https://github.com/kensanata/gridmapper#how-to-save">
	<tspan>Learn More</tspan>
      </a>
      <a fill="blue" xlink:href="https://alexschroeder.ch/">
	<tspan x="30" dy="20">Alex Schroeder</tspan>
      </a>
      <tspan> / </tspan>
      <a fill="blue" xlink:href="https://github.com/kensanata/gridmapper">
	<tspan>Source</tspan>
      </a>
      <tspan> / </tspan>
      <a id="demo" fill="blue" xlink:href="javascript:Demo.start()">
	<tspan>Demo</tspan>
      </a>
      <a fill="blue" xlink:href="javascript:textExport()">
	<tspan x="30" dy="20">Text Export</tspan>
      </a>
      <tspan> / </tspan>
      <a fill="blue" xlink:href="javascript:textImport()">
	<tspan>Text Import</tspan>
      </a>
      <tspan> / </tspan><tspan class="key">Ctrl Enter</tspan>
    </text>

    <text y="375">
      <tspan x="250" class="key">?</tspan><tspan> : toggle help</tspan>
      <tspan x="250" dy="20" class="key">Space</tspan><tspan> : move right</tspan>
      <tspan x="250" dy="20" class="key">Enter</tspan><tspan> : begin new line</tspan>
      <tspan x="250" dy="20" class="key">Arrows</tspan><tspan> : move around</tspan>
      <tspan x="250" dy="20" class="key">Shift Arr.</tspan><tspan> : floor</tspan>
    </text>
  </g>

  <text id="messages" visibility="hidden">
    <tspan class="step1" x="0" y="0">Hello! This is the demo!</tspan>
    <tspan class="step1" x="0" dy="20">We're going to show you how to use this thing.</tspan>
    <code class="step1">(10,10)</code>

    <tspan class="step2" x="0" y="0">You can move around the map using your mouse.</tspan>
    <tspan class="step2" x="0" dy="20">Or you can use the
    <tspan class="key">Arrow keys</tspan> to move around.</tspan>
    <code class="step2">(20,10)(20,20)(10,20)(10,10)</code>

    <tspan class="step3" x="0" y="0">You can draw the floor using your mouse.</tspan>
    <tspan class="step3" x="0" dy="20">Or you can use
    <tspan class="key">Shift</tspan> and the
    <tspan class="key">Arrow keys</tspan>.</tspan>
    <code class="step3">(13,11)ffff(13,12)ffff(13,13)ffff(13,14)ffff(13,15)ffff</code>

    <tspan class="step4" x="0" y="0">In general I recomend using the
    <tspan class="key">Arrow keys</tspan> to move.</tspan>
    <tspan class="step4" x="0" dy="20">Use <tspan class="key">f</tspan>
    to draw or erase the floor.</tspan>
    <code class="step4">(14,16)ff(14,17)ff(11,18)ffffff(11,19)ffffff(11,20)ffffff;ffff-;f--;f--;f--;f-</code>

    <tspan class="step5" x="0" y="0">Things like traps, statues and pillars are easy.</tspan>
    <tspan class="step5" x="0" dy="20">Just use the appropriate key:
    <tspan class="key">t</tspan>,
    <tspan class="key">b</tspan>,
    <tspan class="key">p</tspan>.</tspan>
    <code class="step5">(12,19)t;(11,19)b;(11,18)p p p;(11,20)p p p</code>

    <tspan class="step6" x="0" y="0">Doors are trickier. Use
    <tspan class="key">d</tspan> to rotate the door.</tspan>
    <tspan class="step6" x="0" dy="20">Watch: left, top, right, bottom, and back to left.</tspan>
    <code class="step6">(17,12);d;d;d;d;d</code>

    <tspan class="step7" x="0" y="0">Use
    <tspan class="key">x</tspan> to remove a door you added.</tspan>
    <code class="step7">(17,13);d;x;d;x;d;x</code>

    <tspan class="step8" x="0" y="0">Secret and concealed doors are variants of doors.</tspan>
    <tspan class="step8" x="0" dy="20">Use
    <tspan class="key">v</tspan> to switch between variants.</tspan>
    <code class="step8">(17,14)dff(18,15)fff(19,16)ff;d;v;v;fff(21,17)fff(23,17);d;d;d;v;(21,18)fff</code>

    <tspan class="step9" x="0" y="0">Use <tspan class="key">s</tspan>
    to set stairs and rotate them into place.</tspan>
    <tspan class="step9" x="0" dy="20">Use <tspan class="key">v</tspan>
    to use a variant.</tspan>
    <code class="step9">(11,12)s;s;s;s;(17,12)ffs;s;s;s;v </code>

    <tspan class="step10" x="0" y="0">You can draw on multiple layers.</tspan>
    <tspan class="step10" x="0" dy="20">Use
    <tspan class="key">z</tspan> and <tspan class="key">y</tspan>
    to move up and down.</tspan>
    <code class="step10">z(21,11)fff(20,12)ffff(21,13)fff;y</code>

    <tspan class="step11" x="0" y="0">Place a door and rotate it into place.</tspan>
    <tspan class="step11" x="0" dy="20">Use <tspan class="key">v</tspan> to select the gate variant.</tspan>
    <code class="step11">(15,16);d;d;v;v;v</code>

    <tspan class="step12" x="0" y="0">Use <tspan class="key">n</tspan>
    to place and rotate diagonals.</tspan>
    <code class="step12">(17,15);n;n;n;n(18,14);n;n</code>

    <tspan class="step13" x="0" y="0">You can draw walls using
    <tspan class="key">w</tspan>.</tspan>
    <tspan class="step13" x="0" dy="20">Thus, walls work just like doors.</tspan>
    <code class="step13">(16,18);dv(16,19);w(16,20);w</code>

    <tspan class="step14" x="0" y="0">This gets tedious very fast.</tspan>
    <tspan class="step14" x="0" dy="20">Use
    <tspan class="key">m</tspan> to enter
    <tspan style="font-weight: bold">Wall Mode</tspan>.</tspan>
    <tspan class="step14" x="0" dy="20">Note the shift by half a square!</tspan>
    <code class="step14">z(21,11);m</code>

    <tspan class="step15" x="0" y="0" style="font-weight: bold">Wall Mode</tspan>
    <tspan class="step15">keeps the cursor on the walls.</tspan>
    <tspan class="step15" x="0" dy="20">Doors and walls no longer rotate.</tspan>
    <code class="step15"> w; w;(21.5,13)w; w</code>

    <tspan class="step16" x="0" y="0">Move from wall to wall and use
    <tspan class="key">d</tspan>,
    <tspan class="key">v</tspan>,
    <tspan class="key">w</tspan> or
    <tspan class="key">x</tspan>.</tspan>
    <tspan class="step16" x="0" dy="20">Use
    <tspan class="key">m</tspan> to leave Wall Mode.</tspan>
    <code class="step16">(21,11.5)d; d; d;(21,12.5)d; d; d;(23.5,12)dvm</code>

    <tspan class="step17" x="0" y="0">Use the number keys
    <tspan class="key">0-9</tspan> to add labels.</tspan>
    <tspan class="step17" x="0" dy="20">Use
    <tspan class="key">Delete</tspan> to delete labels.</tspan>
    <code class="step17">(20,12)6y(15,12)1(14,19)2(19,16)4(22,17)5</code>

    <tspan class="step18" x="0" y="0">Well, that's it. The rest is up to you.</tspan>
    <tspan class="step18" x="0" dy="20">What lies beyond the secret doors to the east?</tspan>

  </text>
</svg>
